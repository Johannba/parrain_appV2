===== ./rewards/templatetags/ __init__.py =====
===== ./rewards/templatetags/url_extras.py =====
from django import template

register = template.Library()

@register.simple_tag(takes_context=True)
def abs_uri(context, path: str) -> str:
    """
    Construit une URL absolue à partir d'un path relatif, en utilisant request si dispo.
    Usage dans template:
      {% abs_uri rw.claim_path as claim_abs %}
    """
    request = context.get("request")
    if not path:
        return ""
    return request.build_absolute_uri(path) if request else path
===== ./rewards/signals.py =====
# rewards/signals.py
from django.db.models.signals import pre_save
from django.dispatch import receiver
from .models import Reward

@receiver(pre_save, sender=Reward)
def reward_token_autogen(sender, instance: Reward, **kwargs):
    if not instance.token:
        instance.ensure_token()
===== ./rewards/views_wheels.py =====
===== ./rewards/models.py =====
# rewards/models.py
from datetime import timedelta
import secrets

from django.db import models
from django.utils import timezone
from django.urls import reverse

from accounts.models import Company
from dashboard.models import Client, Referral


class ProbabilityWheel(models.Model):
    """
    Roue (pool) cyclique par entreprise.
    - key   : identifie un tirage (ex: 'base_100', 'very_rare_10000')
    - pool  : liste ordonnée des résultats (ex: ['SOUVENT','SOUVENT',...,'NO_HIT'])
    - idx   : curseur de consommation
    - size  : longueur totale du pool (copie pour debug)
    """
    company = models.ForeignKey(
        Company, on_delete=models.CASCADE, related_name="probability_wheels"
    )
    key = models.SlugField(max_length=64)
    pool = models.JSONField(default=list)
    idx = models.PositiveIntegerField(default=0)
    size = models.PositiveIntegerField(default=0)

    class Meta:
        unique_together = (("company", "key"),)
        indexes = [models.Index(fields=["company", "key"])]

    def __str__(self):
        return f"{self.company} • {self.key} ({self.idx}/{self.size})"


class RewardTemplate(models.Model):
    BUCKETS = (
        ("SOUVENT", "Souvent"),
        ("MOYEN", "Moyen"),
        ("RARE", "Rare"),
        ("TRES_RARE", "Très rare"),
    )

    company = models.ForeignKey(
        Company, on_delete=models.CASCADE, related_name="reward_templates"
    )
    bucket = models.CharField(max_length=10, choices=BUCKETS)

    label = models.CharField(max_length=120, default="-10 % de remise")
    cooldown_months = models.PositiveSmallIntegerField(default=1)
    cooldown_days = models.PositiveIntegerField(default=30)

    # Seuil d’éligibilité
    min_referrals_required = models.PositiveIntegerField(
        default=0,
        help_text="Nombre minimum de parrainages requis pour débloquer cette récompense."
    )

    # Purement affichage (ex. '980/1000')
    probability_display = models.CharField(max_length=20, default="", editable=False)

    class Meta:
        unique_together = (("company", "bucket"),)
        ordering = ("company", "bucket")

    def save(self, *args, **kwargs):
        self.cooldown_days = int(self.cooldown_months) * 30
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.company} • {self.get_bucket_display()} • {self.label}"


class Reward(models.Model):
    BUCKETS = (
        ("SOUVENT", "Souvent"),
        ("MOYEN", "Moyen"),
        ("RARE", "Rare"),
        ("TRES_RARE", "Très rare"),
    )
    STATE_CHOICES = (
        ("PENDING", "En attente"),
        ("SENT", "Envoyée"),
        ("DISABLED", "Désactivée"),
        ("ARCHIVED", "Archivée"),
    )

    company = models.ForeignKey(Company, on_delete=models.CASCADE, related_name="rewards")
    client = models.ForeignKey(Client, on_delete=models.CASCADE, related_name="rewards")

    referral = models.ForeignKey(
        Referral, on_delete=models.CASCADE, related_name="rewards",
        null=True, blank=True
    )

    label = models.CharField(max_length=255)
    bucket = models.CharField(max_length=20, choices=BUCKETS)
    cooldown_days = models.PositiveIntegerField(default=0)
    state = models.CharField(max_length=20, choices=STATE_CHOICES, default="PENDING")
    created_at = models.DateTimeField(auto_now_add=True)

    token = models.CharField(max_length=64, unique=True, db_index=True, null=True, blank=True)
    token_expires_at = models.DateTimeField(null=True, blank=True)

    redeemed_at = models.DateTimeField(null=True, blank=True)
    redeemed_channel = models.CharField(max_length=20, blank=True)

    class Meta:
        indexes = [models.Index(fields=["company", "client", "state"])]
        constraints = [
            models.UniqueConstraint(
                fields=["company", "client", "referral"],
                name="uniq_reward_by_referrer_and_referral",
            )
        ]

    # ----------------- Helpers d’affichage -----------------

    def ensure_token(self, force: bool = False):
        if force or not self.token:
            self.token = secrets.token_urlsafe(24)
        if not self.token_expires_at:
            days = int(self.cooldown_days or 180)
            self.token_expires_at = timezone.now() + timedelta(days=days)

    @property
    def valid_until(self):
        if self.cooldown_days and self.created_at:
            return self.created_at + timedelta(days=int(self.cooldown_days))
        return None

    @property
    def cooldown_label(self) -> str:
        d = int(self.cooldown_days or 0)
        if d == 0:
            return "illimité"
        if d % 30 == 0:
            m = d // 30
            return f"{m} mois" if m > 1 else "1 mois"
        return f"{d} jours"

    def validity_sentence(self) -> str:
        if self.valid_until:
            return f"Validité : {self.cooldown_label} (jusqu’au {timezone.localtime(self.valid_until).strftime('%d/%m/%Y')})"
        return "Validité : illimité"

    @property
    def claim_path(self) -> str:
        return reverse("rewards:use_reward", kwargs={"token": self.token}) if self.token else ""

    @property
    def claim_url(self) -> str:
        return self.claim_path

    def __str__(self):
        return f"{self.label} ({self.get_bucket_display()})"
===== ./rewards/probabilities.py =====
from __future__ import annotations
from dataclasses import dataclass
from typing import Iterable, List, Tuple
from django.db import transaction
from django.utils.text import slugify
from rewards.models import ProbabilityWheel
from accounts.models import Company

# --------- Utilitaires de pool ----------
def build_pool(pairs: Iterable[Tuple[int, str]]) -> List[str]:
    pool: List[str] = []
    for n, val in pairs:
        if n < 0:
            raise ValueError("n négatif")
        pool.extend([val] * n)
    return pool

def interleave(pool: List[str]) -> List[str]:
    from collections import defaultdict, deque
    buckets = defaultdict(deque)
    for v in pool:
        buckets[v].append(v)

    keys = sorted(buckets.keys(), key=lambda k: -len(buckets[k]))
    out: List[str] = []
    while any(buckets[k] for k in keys):
        for k in keys:
            if buckets[k]:
                out.append(buckets[k].popleft())
    return out

# --------- API principale ----------
@dataclass
class WheelSpec:
    key: str
    pairs: Tuple[Tuple[int, str], ...]

def ensure_wheel(company: Company, spec: WheelSpec) -> ProbabilityWheel:
    key = slugify(spec.key)
    raw = build_pool(spec.pairs)
    pool = interleave(raw) if len(set(raw)) > 1 else raw
    with transaction.atomic():
        obj, _created = ProbabilityWheel.objects.select_for_update().get_or_create(
            company=company, key=key, defaults={"pool": pool, "size": len(pool), "idx": 0}
        )
        if obj.size != len(pool) or obj.pool != pool:
            obj.pool = pool
            obj.size = len(pool)
            obj.idx = obj.idx % (len(pool) or 1)
            obj.save(update_fields=["pool", "size", "idx"])
    return obj

def draw(company: Company, key: str) -> str:
    k = slugify(key)
    with transaction.atomic():
        wheel = ProbabilityWheel.objects.select_for_update().get(company=company, key=k)
        if wheel.size == 0:
            raise ValueError("Roue vide")
        value = wheel.pool[wheel.idx]
        wheel.idx = (wheel.idx + 1) % wheel.size
        wheel.save(update_fields=["idx"])
        return value

# --------- Specs prêtes à l’emploi ----------
BASE_100 = WheelSpec(
    key="base_100",
    pairs=((80, "Souvent"), (19, "Moyen"), (1, "Rare")),
)
VERY_RARE_10000 = WheelSpec(
    key="very_rare_10000",
    pairs=((9999, "NO_HIT"), (1, "Très rare")),
)
===== ./rewards/tests/test_real_draws.py =====
# rewards/tests/test_real_draws.py
import pytest
from collections import Counter
from django.utils import timezone

from accounts.models import Company
from dashboard.models import Client, Referral
from rewards.models import RewardTemplate
from rewards.services.probabilities import (
    ensure_wheels, tirer_recompense,
    SOUVENT, MOYEN, RARE, TRES_RARE,
)

pytestmark = pytest.mark.django_db


# ----------------------------
# Helpers
# ----------------------------

def _mk_company_with_templates(
    name="Acme",
    min_rare=0,
    min_tres_rare=0,
    label_map=None,
):
    """
    Crée une entreprise + les 4 RewardTemplate avec les minimums d’éligibilité voulus.
    Les probas affichées ne servent que d'info; la vraie distribution vient des roues.
    """
    c = Company.objects.create(name=name, slug=name.lower())
    defaults = {
        SOUVENT:   {"label": "-10 %", "cooldown_months": 1, "min": 0,           "prob": "980/1000"},
        MOYEN:     {"label": "-20 %", "cooldown_months": 1, "min": 0,           "prob": "19/1000"},
        RARE:      {"label": "Rare",  "cooldown_months": 3, "min": min_rare,    "prob": "1/1000"},
        TRES_RARE: {"label": "Jackpot","cooldown_months": 6,"min": min_tres_rare,"prob": "1/100000"},
    }
    label_map = label_map or {}
    for bucket, meta in defaults.items():
        RewardTemplate.objects.create(
            company=c,
            bucket=bucket,
            label=label_map.get(bucket, meta["label"]),
            cooldown_months=meta["cooldown_months"],
            min_referrals_required=meta["min"],
            probability_display=meta["prob"],
        )
    ensure_wheels(c)  # pool base (1000) et very_rare (100000) à idx=0
    return c


def _client(company, first="A", last="B"):
    return Client.objects.create(company=company, first_name=first, last_name=last)


def _seed_referrals(company, referrer, n):
    """Crée n parrainages où `referrer` est le parrain (le filleul importe peu ici)."""
    for i in range(n):
        referee = Client.objects.create(company=company, first_name=f"F{i}", last_name="X")
        Referral.objects.create(
            company=company, referrer=referrer, referee=referee, created_at=timezone.now()
        )


def _draw_n(company, client, n):
    cnt = Counter()
    for _ in range(n):
        cnt[tirer_recompense(company, client)] += 1
    # S’assure que toutes les clés existent
    for k in (SOUVENT, MOYEN, RARE, TRES_RARE):
        cnt.setdefault(k, 0)
    return cnt


# ----------------------------
# Tests “partie réelle” (consommation des roues)
# ----------------------------

def test_first_100_draws_from_fresh_cycle_are_all_souvent():
    """
    Avec des roues neuves (idx=0) et client éligible à tout,
    les 100 premiers tirages tombent forcément sur SOUVENT (pool base ordonné).
    """
    c = _mk_company_with_templates(name="AllEligible")
    client = _client(c)
    cnt = _draw_n(c, client, 100)
    assert cnt[SOUVENT] == 100
    assert cnt[MOYEN] == cnt[RARE] == cnt[TRES_RARE] == 0


def test_full_base_cycle_1000_all_eligible_gives_980_19_1():
    """
    Sur un cycle complet de la roue base (1000 tirages) avec tout éligible :
    980 SOUVENT, 19 MOYEN, 1 RARE. TRES_RARE n’apparaît pas avant 100000 tirages.
    """
    c = _mk_company_with_templates(name="Cycle1000")  # tout éligible
    client = _client(c)
    cnt = _draw_n(c, client, 1000)
    assert cnt[SOUVENT] == 980
    assert cnt[MOYEN] == 19
    assert cnt[RARE] == 1
    assert cnt[TRES_RARE] == 0


def test_very_rare_exactly_once_per_100000_when_eligible():
    """
    Quand TRES_RARE est éligible, il sort exactement 1 fois par cycle de 100000 tirages.
    Les 99999 autres tirages consomment la roue base (99 cycles complets + 999 entrées).
    """
    c = _mk_company_with_templates(name="VeryRareEligible")
    client = _client(c)

    cnt = _draw_n(c, client, 100_000)

    # 1 seul TRES_RARE
    assert cnt[TRES_RARE] == 1

    # Répartition base attendue sur 99 cycles + 999 tirages (indices 0..998)
    # 99 cycles -> 99*980, 99*19, 99*1
    # +999 tirages -> 980 SOUVENT + 19 MOYEN
    assert cnt[SOUVENT] == 98_000   # 97_020 + 980
    assert cnt[MOYEN]   == 1_900    # 1_881 + 19
    assert cnt[RARE]    == 99       # 99
    # Somme de contrôle
    assert sum(cnt.values()) == 100_000


def test_ineligible_rare_and_very_rare_gives_981_souvent_19_moyen_on_1000():
    """
    Seuils RARE=10, TRES_RARE=12 ; client avec 9 parrainages => RARE/TRES_RARE inéligibles.
    Sur 1000 tirages, la case RARE (dernière du pool base) est “sautée” et remplacée par
    la case suivante autorisée => 981 SOUVENT, 19 MOYEN, 0 RARE, 0 TRES_RARE.
    """
    c = _mk_company_with_templates(name="MinThresholds", min_rare=10, min_tres_rare=12)
    client = _client(c)
    _seed_referrals(c, client, 9)  # inéligible à RARE/TRES_RARE

    cnt = _draw_n(c, client, 1000)
    assert cnt[SOUVENT] == 981
    assert cnt[MOYEN] == 19
    assert cnt[RARE] == 0
    assert cnt[TRES_RARE] == 0


def test_rare_becomes_eligible_at_10_but_tres_rare_not_yet():
    """
    À 10 parrainages : RARE devient éligible, pas TRES_RARE.
    On retrouve donc 980/19/1 sur 1000 tirages.
    """
    c = _mk_company_with_templates(name="RareOnly", min_rare=10, min_tres_rare=12)
    client = _client(c)
    _seed_referrals(c, client, 10)

    cnt = _draw_n(c, client, 1000)
    assert cnt[SOUVENT] == 980
    assert cnt[MOYEN] == 19
    assert cnt[RARE] == 1
    assert cnt[TRES_RARE] == 0


def test_tres_rare_apparait_juste_apres_99999_tirs_quand_il_devient_eligible():
    """
    Démonstration du “skip” propre :
    - On tire 99 999 fois alors que TRES_RARE est inéligible -> on consomme tout le NO_HIT.
    - On rend ensuite TRES_RARE éligible -> le tirage suivant tombe sur la case TRES_RARE.
    """
    # Au départ TR inéligible
    c = _mk_company_with_templates(name="EnableLater", min_rare=0, min_tres_rare=1)
    client = _client(c)

    # 0 parrainage -> TR inéligible
    cnt1 = _draw_n(c, client, 99_999)
    assert cnt1[TRES_RARE] == 0

    # Devient éligible (1 parrainage)
    _seed_referrals(c, client, 1)
    cnt2 = _draw_n(c, client, 1)
    assert cnt2[TRES_RARE] == 1
===== ./rewards/tests/__init__.py =====
===== ./rewards/tests/test_sms_send.py =====
import pytest
from django.urls import reverse

@pytest.mark.django_db
def test_reward_send_sms_requires_login(client):
    url = reverse("rewards:reward_send_sms", kwargs={"pk": 1})
    resp = client.post(url)
    assert resp.status_code in (302, 301)  # redirection vers login
===== ./rewards/management/ __init__.py =====
===== ./rewards/management/commands/init_probability_wheels.py =====
from django.core.management.base import BaseCommand, CommandError
from accounts.models import Company
from rewards.services.probabilities import ensure_wheels

class Command(BaseCommand):
    help = "Initialise les roues de probabilité pour une entreprise."

    def add_arguments(self, parser):
        parser.add_argument("--company", required=True, help="Slug de l'entreprise")

    def handle(self, *args, **options):
        slug = options["company"]
        try:
            company = Company.objects.get(slug=slug)
        except Company.DoesNotExist:
            raise CommandError(f"Company '{slug}' introuvable")

        ensure_wheels(company)
        self.stdout.write(self.style.SUCCESS(f"OK: {company} • base & very_rare"))
===== ./rewards/management/commands/seed_wheels.py =====
from django.core.management.base import BaseCommand
from accounts.models import Company
from rewards.services.probabilities import ensure_wheels_for_company

class Command(BaseCommand):
    help = "Initialise (ou ré-initialise) les roues de probabilités pour chaque entreprise."

    def add_arguments(self, parser):
        parser.add_argument(
            "--reset",
            action="store_true",
            help="Ré-initialise les roues (réécrit le pool et remet idx=0)."
        )

    def handle(self, *args, **options):
        reset = options["reset"]
        count = 0
        for company in Company.objects.all():
            ensure_wheels_for_company(company)
            count += 1
        self.stdout.write(self.style.SUCCESS(
            f"Roues initialisées pour {count} entreprise(s)."
        ))
        if reset:
            # Optionnel : si tu veux forcer un reset plus fort, tu peux
            # étendre ensure_wheels_for_company pour régénérer les pools
            self.stdout.write(self.style.WARNING(
                "Option --reset indiquée : assure-toi que ensure_wheels_for_company "
                "régénère les pools comme attendu."
            ))
===== ./rewards/management/commands/ __init__.py =====
===== ./rewards/management/commands/rebuild_wheels.py =====
from django.core.management.base import BaseCommand
from accounts.models import Company
from rewards.services.probabilities import ensure_wheels

class Command(BaseCommand):
    help = "Reconstruit/initialise les roues de probabilité pour chaque entreprise."

    def handle(self, *args, **opts):
        for c in Company.objects.filter(is_active=True):
            ensure_wheels(c)
            self.stdout.write(self.style.SUCCESS(f"{c.name}: wheels ensured"))
===== ./rewards/__init__.py =====
===== ./rewards/apps.py =====
# rewards/apps.py
from django.apps import AppConfig

class RewardsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "rewards"
    verbose_name = "Récompenses"

    def ready(self):
        import rewards.signals  # noqa
===== ./rewards/forms.py =====
# rewards/forms.py
from django import forms
from .models import RewardTemplate

class RewardTemplateForm(forms.ModelForm):
    # Limite à 17 caractères (serveur) + maxlength côté HTML
    label = forms.CharField(
        max_length=17,
        label="Nom de la récompense",
        widget=forms.TextInput(attrs={
            "class": "form-control",
            "placeholder": "Ex. -10 %",
            "maxlength": "17",   # limite côté navigateur
        }),
        error_messages={
            "max_length": "Maximum 17 caractères.",
        },
    )

    cooldown_months = forms.TypedChoiceField(
        choices=[(i, f"{i} mois") for i in range(1, 7)],
        coerce=int,
        label="Délai",
        widget=forms.Select(attrs={"class": "form-select"})
    )

    min_referrals_required = forms.IntegerField(
        min_value=0,
        label="Minimum de parrainages requis",
        widget=forms.NumberInput(attrs={
            "class": "form-control",
            "placeholder": "0",
            "inputmode": "numeric"
        })
    )

    class Meta:
        model = RewardTemplate
        fields = ("label", "cooldown_months", "min_referrals_required")

    def clean_label(self):
        """Validation supplémentaire (au cas où, après trim)."""
        value = (self.cleaned_data.get("label") or "").strip()
        if len(value) > 17:
            raise forms.ValidationError("Maximum 17 caractères.")
        return value
===== ./rewards/admin.py =====
# rewards/admin.py
from django.contrib import admin, messages
from django.db import IntegrityError, transaction
from django.utils.translation import gettext_lazy as _

from .models import ProbabilityWheel, RewardTemplate, Reward


@admin.action(description="Marquer sélection comme Envoyée")
def mark_sent(modeladmin, request, queryset):
    updated = queryset.update(state="SENT")
    messages.success(request, _(f"{updated} récompense(s) marquée(s) comme envoyée(s)."))

@admin.action(description="Marquer sélection comme En attente")
def mark_pending(modeladmin, request, queryset):
    updated = queryset.update(state="PENDING")
    messages.success(request, _(f"{updated} récompense(s) marquée(s) comme en attente."))

@admin.action(description="Marquer sélection comme Désactivée")
def mark_disabled(modeladmin, request, queryset):
    updated = queryset.update(state="DISABLED")
    messages.success(request, _(f"{updated} récompense(s) désactivée(s)."))

@admin.action(description="Archiver la sélection")
def mark_archived(modeladmin, request, queryset):
    updated = queryset.update(state="ARCHIVED")
    messages.success(request, _(f"{updated} récompense(s) archivée(s)."))

@admin.register(Reward)
class RewardAdmin(admin.ModelAdmin):
    list_display = (
        "company", "client", "referral",
        "label", "bucket", "state", "created_at",
    )
    list_filter = (
        "company", "bucket", "state", ("created_at", admin.DateFieldListFilter),
    )
    search_fields = (
        "label",
        "client__last_name", "client__first_name",
        "client__email", "client__phone",
    )
    list_select_related = ("company", "client", "referral")
    autocomplete_fields = ("client", "referral")
    date_hierarchy = "created_at"
    ordering = ("-created_at", "-id")
    actions = [mark_sent, mark_pending, mark_disabled, mark_archived]

    def save_model(self, request, obj, form, change):
        try:
            with transaction.atomic():
                super().save_model(request, obj, form, change)
        except IntegrityError:
            self.message_user(
                request,
                _("Une récompense existe déjà pour ce parrainage et ce parrain (règle: 1 par filleul)."),
                level=messages.ERROR,
            )

@admin.register(RewardTemplate)
class RewardTemplateAdmin(admin.ModelAdmin):
    list_display = (
        "company", "bucket", "label",
        "cooldown_months", "cooldown_days", "probability_display",
    )
    list_filter = ("company", "bucket")
    search_fields = ("label", "company__name")
    ordering = ("company", "bucket")
    readonly_fields = ("cooldown_days", "probability_display")

@admin.action(description="(Re)créer les deux roues pour l’entreprise (ensure_wheels)")
def action_ensure_wheels(modeladmin, request, queryset):
    companies = {w.company for w in queryset}
    for c in companies:
        ensure_wheels(c)
    messages.success(request, _(f"Roues vérifiées/régénérées pour {len(companies)} entreprise(s)."))

@admin.action(description="Régénérer la roue sélectionnée (repart à idx=0)")
def action_rebuild_selected(modeladmin, request, queryset):
    for w in queryset:
        key = w.key
        try:
            rebuild_wheel(w.company, key)
        except ValueError:
            messages.error(request, _(f"Clé inconnue pour {w}: {key}"))
    messages.success(request, _("Roue(s) régénérée(s)."))

@admin.action(description="Remettre le curseur (idx) à 0")
def action_reset_idx(modeladmin, request, queryset):
    for w in queryset:
        reset_wheel(w.company, w.key)
    messages.success(request, _("Curseur réinitialisé à 0 pour la sélection."))

@admin.register(ProbabilityWheel)
class ProbabilityWheelAdmin(admin.ModelAdmin):
    list_display = ("company", "key", "size", "idx")
    list_filter = ("company", "key")
    search_fields = ("company__name", "key")
    readonly_fields = ("size", "idx")
    actions = [action_ensure_wheels, action_rebuild_selected, action_reset_idx]
===== ./rewards/utils.py =====
from django import template
register = template.Library()

@register.filter
def get_item(d, key):
    try:
        return d.get(key)
    except Exception:
        return None
===== ./rewards/urls.py =====
# rewards/urls.py
from django.urls import path
from .views import (
    reward_list, reward_update, rewards_history_company, reward_spin,
    use_reward, distribute_reward, referral_delete,rewards_stats,test_wheel, reward_send_sms
)

app_name = "rewards"

urlpatterns = [
    path("", reward_list, name="list"),
    path("<int:pk>/edit/", reward_update, name="edit"),
    path("<int:pk>/update/", reward_update, name="update"), 
    path("history/", rewards_history_company, name="history_company"),
    path("stats/", rewards_stats, name="stats"),  
    path("spin/<int:reward_id>/", reward_spin, name="spin"),
    path("use/<str:token>/", use_reward, name="use_reward"),
    path("distribute/<int:pk>/", distribute_reward, name="distribute"),
    path("referral/<int:pk>/delete/", referral_delete, name="referral_delete"),
    path("test-wheel/", test_wheel, name="test_wheel"), 
    path("<int:pk>/send/sms/", reward_send_sms, name="reward_send_sms"),
    
]
===== ./rewards/notifications/services.py =====
# rewards/notifications/services.py
import os
from twilio.rest import Client as TwilioClient

def send_sms(to: str, body: str) -> tuple[bool, str | None]:
    """
    Envoie un SMS via Twilio.
    Retourne (True, None) si OK, sinon (False, "erreur ...").
    """
    sid = os.getenv("TWILIO_ACCOUNT_SID")
    token = os.getenv("TWILIO_AUTH_TOKEN")
    sender = os.getenv("TWILIO_FROM_NUMBER")
    if not (sid and token and sender):
        return False, "Configuration Twilio manquante (env: TWILIO_*)."
    if not to:
        return False, "Numéro du destinataire manquant."

    try:
        client = TwilioClient(sid, token)
        client.messages.create(to=to, from_=sender, body=body)
        return True, None
    except Exception as e:
        return False, str(e)
===== ./rewards/services/probabilities.py =====
# rewards/services/probabilities.py
from __future__ import annotations
from dataclasses import dataclass
from decimal import Decimal, getcontext
from typing import Dict, List, Tuple, Set

from django.db import transaction
from django.shortcuts import render

from accounts.models import Company
from rewards.models import ProbabilityWheel, RewardTemplate
from dashboard.models import Referral

# Compatibilité avec les anciens helpers/tests
from rewards.probabilities import (
    WheelSpec as _LegacyWheelSpec,
    ensure_wheel as _legacy_ensure_wheel,
    draw as _legacy_draw,
)


# Expose les symboles historiques
WheelSpec = _LegacyWheelSpec
ensure_wheel = _legacy_ensure_wheel
draw = _legacy_draw

# ------------------ Définition des deux roues “exactes” ------------------
BASE_KEY = "base_100"           # 1000 cases = 980/19/1
VERY_RARE_KEY = "very_rare_10000"  # 100_000 cases = 1 TRES_RARE

SOUVENT = "SOUVENT"
MOYEN = "MOYEN"
RARE = "RARE"
TRES_RARE = "TRES_RARE"
NO_HIT = "NO_HIT"

BASE_COUNTS = {SOUVENT: 980, MOYEN: 19, RARE: 1}
BASE_SIZE = sum(BASE_COUNTS.values())  # 1000

VR_COUNTS = {NO_HIT: 100_000 - 1, TRES_RARE: 1}
VR_SIZE = sum(VR_COUNTS.values())  # 100_000

getcontext().prec = 28  # précision si on affiche des pourcentages

def _build_base_pool() -> List[str]:
    pool: List[str] = []
    for token, n in BASE_COUNTS.items():
        pool.extend([token] * n)
    return pool

def _build_very_rare_pool() -> List[str]:
    pool: List[str] = []
    for token, n in VR_COUNTS.items():
        pool.extend([token] * n)
    return pool

@transaction.atomic
def ensure_wheels(company: Company) -> Tuple[ProbabilityWheel, ProbabilityWheel]:
    """
    Crée (ou met à niveau) les deux roues exactes pour l’entreprise.
    """
    base, _ = ProbabilityWheel.objects.get_or_create(
        company=company,
        key=BASE_KEY,
        defaults={"pool": _build_base_pool(), "size": BASE_SIZE, "idx": 0},
    )
    very_rare, _ = ProbabilityWheel.objects.get_or_create(
        company=company,
        key=VERY_RARE_KEY,
        defaults={"pool": _build_very_rare_pool(), "size": VR_SIZE, "idx": 0},
    )

    if base.size != BASE_SIZE:
        base.pool, base.size, base.idx = _build_base_pool(), BASE_SIZE, 0
        base.save(update_fields=["pool", "size", "idx"])

    if very_rare.size != VR_SIZE:
        very_rare.pool, very_rare.size, very_rare.idx = _build_very_rare_pool(), VR_SIZE, 0
        very_rare.save(update_fields=["pool", "size", "idx"])

    return base, very_rare

def rebuild_wheel(company: Company, key: str) -> None:
    if key == BASE_KEY:
        pool, size = _build_base_pool(), BASE_SIZE
    elif key == VERY_RARE_KEY:
        pool, size = _build_very_rare_pool(), VR_SIZE
    else:
        raise ValueError(f"Clé de roue inconnue: {key}")

    ProbabilityWheel.objects.update_or_create(
        company=company, key=key,
        defaults={"pool": pool, "size": size, "idx": 0}
    )

def reset_wheel(company: Company, key: str) -> None:
    wheel = ProbabilityWheel.objects.get(company=company, key=key)
    wheel.idx = 0
    wheel.save(update_fields=["idx"])

def _eligible_buckets_for(company: Company, client) -> Dict[str, bool]:
    """
    Détermine l'éligibilité par bucket pour un client, en fonction de son
    nombre de parrainages (en tant que parrain).
    """
    referrals_count = Referral.objects.filter(
        company=company, referrer=client
    ).count()

    tpls = {
        t.bucket: t
        for t in RewardTemplate.objects.filter(company=company).only(
            "bucket", "min_referrals_required"
        )
    }

    def is_ok(bucket: str) -> bool:
        tpl = tpls.get(bucket)
        if not tpl:
            return False
        return referrals_count >= int(tpl.min_referrals_required or 0)

    return {
        SOUVENT: bool(tpls.get(SOUVENT)),
        MOYEN:   bool(tpls.get(MOYEN)),
        RARE:    is_ok(RARE),
        TRES_RARE: is_ok(TRES_RARE),
    }

def _consume_one_eligible(wheel: ProbabilityWheel, allowed: Set[str]) -> str:
    """
    Consomme la roue en sautant les cases non autorisées.
    Normalisation implicite et déterminisme conservé.
    """
    if wheel.size == 0:
        raise ValueError("Roue vide")

    for _ in range(wheel.size):
        val = wheel.pool[wheel.idx]
        wheel.idx = (wheel.idx + 1) % wheel.size
        if val in allowed:
            wheel.save(update_fields=["idx"])
            return val

    # Rien d'autorisé trouvé sur un cycle complet
    wheel.save(update_fields=["idx"])
    return NO_HIT

def tirer_recompense(company: Company, client) -> str:
    """
    Tirage “client-aware” :
      1) very_rare : autorise TRES_RARE seulement si éligible (sinon NO_HIT).
      2) base      : autorise SOUVENT/MOYEN/RARE selon éligibilité.
    """
    elig = _eligible_buckets_for(company, client)
    base, very_rare = ensure_wheels(company)

    allowed_vr = {NO_HIT}
    if elig.get(TRES_RARE, False):
        allowed_vr.add(TRES_RARE)

    vr = _consume_one_eligible(very_rare, allowed_vr)
    if vr == TRES_RARE:
        return TRES_RARE

    allowed_base: Set[str] = set()
    if elig.get(SOUVENT, False): allowed_base.add(SOUVENT)
    if elig.get(MOYEN,   False): allowed_base.add(MOYEN)
    if elig.get(RARE,    False): allowed_base.add(RARE)
    if not allowed_base:
        allowed_base = {SOUVENT}

    return _consume_one_eligible(base, allowed_base)

# Ajoute ceci dans rewards/services/probabilities.py

from decimal import Decimal, getcontext  # tu l'as déjà en haut du fichier
getcontext().prec = 28  # pour éviter les erreurs d'arrondi

def get_normalized_percentages(company: Company, client) -> Dict[str, Decimal]:
    """
    Calcule les pourcentages affichés côté UI en partant des probabilités
    “canoniques” demandées (avant seuils) puis en RENORMALISANT pour que
    la somme fasse exactement 100, en tenant compte de l'éligibilité.
      - SOUVENT   = 80 / 100
      - MOYEN     = 19 / 100
      - RARE      = 0.99999 / 100
      - TRES_RARE = 1 / 100000
    """
    elig = _eligible_buckets_for(company, client)

    # Poids de base (sur [0..1])
    p_base = {
        SOUVENT: Decimal("80") / Decimal("100"),        # 0.80
        MOYEN:   Decimal("19") / Decimal("100"),        # 0.19
        RARE:    Decimal("0.99999") / Decimal("100"),   # 0.0099999
    }
    p_tr = {TRES_RARE: Decimal(1) / Decimal(100000)}     # 0.00001

    # Masse des catégories autorisées
    mass = Decimal(0)
    for b, p in p_base.items():
        if elig.get(b, False):
            mass += p
    if elig.get(TRES_RARE, False):
        mass += p_tr[TRES_RARE]

    # Aucun bucket autorisé -> fallback lisible
    if mass == 0:
        return {
            SOUVENT:   Decimal(100),
            MOYEN:     Decimal(0),
            RARE:      Decimal(0),
            TRES_RARE: Decimal(0),
        }

    # Renormalisation -> la somme fait exactement 100
    return {
        SOUVENT:   (p_base[SOUVENT] / mass) * Decimal(100) if elig.get(SOUVENT, False)   else Decimal(0),
        MOYEN:     (p_base[MOYEN]   / mass) * Decimal(100) if elig.get(MOYEN,   False)   else Decimal(0),
        RARE:      (p_base[RARE]    / mass) * Decimal(100) if elig.get(RARE,    False)   else Decimal(0),
        TRES_RARE: (p_tr[TRES_RARE] / mass) * Decimal(100) if elig.get(TRES_RARE, False) else Decimal(0),
    }


===== ./rewards/services/__init__.py =====
# rewards/services/__init__.py
from .core import create_reward_from_template, award_both_parties
===== ./rewards/services/core.py =====
# rewards/services/core.py
from datetime import timedelta
from django.db import transaction
from django.utils import timezone

from ..models import RewardTemplate, Reward  # ⬅️ import relatif (note les deux points)


def create_reward_from_template(*, company, client, tpl, referral=None, label=None) -> Reward:
    """
    Crée une Reward à partir d’un RewardTemplate en recopiant le cooldown_days.
    Idempotent ? -> Non. Si tu veux éviter les doublons, vérifie avant.
    """
    reward = Reward(
        company=company,
        client=client,
        referral=referral,
        label=label or tpl.label,
        bucket=tpl.bucket,
        cooldown_days=tpl.cooldown_days or 0,
        state="PENDING",
    )
    reward.ensure_token()
    # Optionnel : aligner expiration du lien sur le délai d’utilisation
    if reward.cooldown_days and not reward.token_expires_at:
        reward.token_expires_at = timezone.now() + timedelta(days=int(reward.cooldown_days))
    reward.save()
    return reward


@transaction.atomic
def award_both_parties(*, referral, bucket_referrer="SOUVENT", bucket_referee="SOUVENT"):
    """
    Attribue une récompense au parrain ET au filleul pour un même Referral.
    - Par défaut, même bucket pour les deux ('SOUVENT'). Change si besoin.
    - Idempotent au niveau (company, client, referral) grâce à une vérif avant création.
    """
    company = referral.company
    referrer = referral.referrer
    referee = referral.referee

    # Choix des templates (tu peux changer la logique de sélection ici)
    tpl_referrer = RewardTemplate.objects.get(company=company, bucket=bucket_referrer)
    tpl_referee  = RewardTemplate.objects.get(company=company, bucket=bucket_referee)

    # Évite doublons : unique (company, client, referral)
    reward_referrer = Reward.objects.filter(company=company, client=referrer, referral=referral).first()
    if not reward_referrer:
        reward_referrer = create_reward_from_template(
            company=company, client=referrer, tpl=tpl_referrer, referral=referral
        )

    reward_referee = Reward.objects.filter(company=company, client=referee, referral=referral).first()
    if not reward_referee:
        reward_referee = create_reward_from_template(
            company=company, client=referee, tpl=tpl_referee, referral=referral
        )

    return reward_referrer, reward_referee
===== ./rewards/services/smsmode.py =====
# rewards/services/smsmode.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, Optional
import json
import logging
import re
import requests
from django.conf import settings

logger = logging.getLogger(__name__)

# =========================
# Modèles de données
# =========================

@dataclass
class SMSPayload:
    to: str
    text: str
    sender: Optional[str] = None

@dataclass
class SMSResult:
    ok: bool
    provider_id: Optional[str]
    status: str
    raw: Dict[str, Any]

# =========================
# Normalisation E.164 (FR + DROM + HT)
# =========================

E164_RE = re.compile(r"^\+\d{6,15}$")

def _digits_plus(s: str) -> str:
    """Garde uniquement chiffres et +."""
    return re.sub(r"[^\d\+]", "", s or "")

def normalize_msisdn(phone: str) -> str:
    """
    Normalise en E.164 pour :
      - France métropolitaine : 0X XX XX XX XX  -> +33 X...
      - Guadeloupe : 0590/0690 -> +590590... / +590690...
      - Martinique : 0596/0696 -> +596596... / +596696...
      - Guyane : 0594/0694     -> +594594... / +594694...
      - La Réunion : 0262/0692/0693 -> +262262... / +262692... / +262693...
      - Mayotte : 0269/0639        -> +262269... / +262639...
      - Haïti : 8 chiffres locaux  -> +509XXXXXXXX
    Règles :
      - '00' prefix => remplacé par '+'
      - si déjà E.164, renvoyé tel quel
      - si commence par indicatif sans '+', on ajoute '+'
    """
    raw = (phone or "").strip()
    p = _digits_plus(raw).replace(" ", "")

    # 00 => +
    if p.startswith("00"):
        p = "+" + p[2:]

    # déjà E.164 ?
    if E164_RE.match(p):
        return p

    # indicatifs DOM/HT sans '+'
    for cc in ("590", "596", "594", "262", "509"):
        if p.startswith(cc) and p[len(cc):].isdigit():
            return f"+{p}"

    # France/DOM formats nationaux (10 chiffres, commence par 0)
    if p.startswith("0") and len(p) == 10 and p.isdigit():
        n = p[1:]  # sans le 0
        # DOM fixes/mobiles
        if n.startswith(("590", "690")):  # Guadeloupe
            return f"+590{n}"
        if n.startswith(("596", "696")):  # Martinique
            return f"+596{n}"
        if n.startswith(("594", "694")):  # Guyane
            return f"+594{n}"
        if n.startswith(("262", "692", "693")):  # Réunion
            return f"+262{n}"
        if n.startswith(("269", "639")):  # Mayotte
            return f"+262{n}"  # E.164 Mayotte utilise +262

        # Métropole
        if n[0] in "12345":      # 01..05 -> +331..+335
            return f"+33{n[0]}{n[1:]}"
        if n[0] == "6":          # 06 -> +336
            return f"+33{n}"
        if n[0] == "7":          # 07 -> +337
            return f"+33{n}"

    # Haïti local sans trunk (8 chiffres)
    if len(p) == 8 and p.isdigit():
        return f"+509{p}"

    # 9 chiffres commençant par indicatifs DOM
    if len(p) == 9 and p.isdigit():
        if p.startswith(("590", "596", "594", "262")):
            return f"+{p[:3]}{p}"
        if p.startswith("690"):
            return f"+590{p}"
        if p.startswith("696"):
            return f"+596{p}"
        if p.startswith("694"):
            return f"+594{p}"
        if p.startswith(("692", "693")):
            return f"+262{p}"
        if p.startswith(("269", "639")):
            return f"+262{p}"

    # 9 chiffres métropole mobiles sans 0
    if len(p) == 9 and p.isdigit() and p[0] in ("6", "7"):
        return f"+33{p}"

    # Rien de concluant => renvoyer brut (le provider peut refuser si invalide)
    return raw

# =========================
# Message métier
# =========================

def build_reward_sms_text(*, client_fullname: str, claim_absolute_url: str, company_name: str | None) -> str:
    parts = []
    parts.append(f"{company_name}:" if company_name else "Votre récompense :")
    parts.append(
        f"{client_fullname}, vous avez une récompense en attente."
        if client_fullname else
        "Vous avez une récompense en attente."
    )
    parts.append(f"Utilisez-la ici : {claim_absolute_url}")
    return " ".join(parts)

# =========================
# Construction d'URL smsmode
# =========================

def _build_smsmode_url() -> str:
    """
    Construit l'URL finale sans double 'sms/v1'.
    - Si BASE_URL se termine déjà par '/sms/v1' => ajoute '/messages'
    - Sinon => ajoute '/sms/v1/messages'
    """
    base = settings.SMSMODE["BASE_URL"].rstrip("/")  # ex: https://rest.smsmode.com
    if base.endswith("/sms/v1"):
        return f"{base}/messages"
    return f"{base}/sms/v1/messages"

# =========================
# Envoi
# =========================

def send_sms(payload: SMSPayload) -> SMSResult:
    """
    Envoi via smsmode.
    Auth: header 'X-Api-Key: <API_KEY>'
    Endpoint attendu: https://rest.smsmode.com/sms/v1/messages

    Corps JSON (conforme smsmode):
      {
        "recipient": {"to": "+33XXXXXXXXX"},
        "body": {"text": "message"},
        "from": "ParrainApp"  # optionnel selon contrat
      }
    """
    if settings.SMSMODE.get("DRY_RUN"):
        logger.info("[SMSMODE DRY-RUN] %s", payload)
        return SMSResult(ok=True, provider_id=None, status="DRY_RUN", raw={"dry_run": True})

    url = _build_smsmode_url()

    headers = {
        "X-Api-Key": settings.SMSMODE["API_KEY"],   # ✅ auth correcte
        "Content-Type": "application/json",
        "Accept": "application/json",
    }

    data: Dict[str, Any] = {
        "recipient": {"to": payload.to},   # <- champ attendu
        "body": {"text": payload.text},    # <- champ attendu
    }
    if payload.sender:
        data["from"] = payload.sender      # optionnel selon votre contrat

    logger.info("SMSMODE POST %s to=%s sender=%s", url, payload.to, payload.sender or "")

    try:
        resp = requests.post(url, headers=headers, data=json.dumps(data), timeout=settings.SMSMODE["TIMEOUT"])
        ctype = (resp.headers.get("Content-Type") or "").lower()
        raw: Dict[str, Any] = resp.json() if "application/json" in ctype else {"text": resp.text}
        ok = 200 <= resp.status_code < 300

        # id de message (peut être messageId ou messageIds[])
        provider_id: Optional[str] = None
        if isinstance(raw.get("messageIds"), list) and raw["messageIds"]:
            provider_id = raw["messageIds"][0]
        else:
            provider_id = raw.get("messageId")

        status = raw.get("status") or ("OK" if ok else f"HTTP_{resp.status_code}")
        if not ok:
            logger.error("SMSMODE error: %s (status=%s url=%s)", raw, resp.status_code, url)

        return SMSResult(ok=ok, provider_id=provider_id, status=status, raw=raw)

    except Exception as e:
        logger.exception("SMSMODE exception")
        return SMSResult(ok=False, provider_id=None, status=f"EXC:{e}", raw={})
===== ./rewards/views.py =====
# rewards/views.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
import random
import secrets

from django.conf import settings
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.core.exceptions import PermissionDenied
from django.core.paginator import Paginator
from django.db import transaction
from django.db.models import Q, Count
from django.db.models.functions import TruncMonth
from django.http import Http404
from django.shortcuts import render, redirect, get_object_or_404
from django.utils import timezone
from django.views.decorators.http import require_POST

from accounts.models import Company
from dashboard.models import Referral
from .models import RewardTemplate, Reward, ProbabilityWheel
from .forms import RewardTemplateForm
from rewards.services.probabilities import BASE_COUNTS, VR_COUNTS, BASE_SIZE, VR_SIZE
from .services.smsmode import SMSPayload, send_sms, build_reward_sms_text, normalize_msisdn


# ----------------------------- UI Dictionaries -----------------------------

BUCKET_UI = {
    "SOUVENT":   {"label": "Souvent",   "badge": "success", "prob": "980/1000"},
    "MOYEN":     {"label": "Moyen",     "badge": "info",    "prob": "19/1000"},
    "RARE":      {"label": "Rare",      "badge": "warning", "prob": "1/1000"},
    "TRES_RARE": {"label": "Très rare", "badge": "danger",  "prob": "1/100000"},
}

STATE_UI = {
    "PENDING":  {"label": "En attente",   "badge": "warning"},
    "SENT":     {"label": "Envoyée",      "badge": "success"},
    "DISABLED": {"label": "Désactivée",   "badge": "secondary"},
    "ARCHIVED": {"label": "Archivée",     "badge": "dark"},
}


# ----------------------------- Helpers généraux -----------------------------

def _is_superadmin(u) -> bool:
    return hasattr(u, "is_superadmin") and u.is_superadmin()

def _company_for(u):
    return getattr(u, "company", None)

def _current_company(request, *, allow_default_for_superadmin: bool = True) -> Company | None:
    """
    Admin/Opérateur : user.company
    Superadmin :
      - si ?company=… fourni → utilise cet id (string possible)
      - sinon id mémorisé en session (souvent un int)
      - sinon (si allow_default_for_superadmin) → 1ʳᵉ entreprise
    """
    user = request.user

    # Cas Admin/Opérateur : on retourne simplement son entreprise
    if not _is_superadmin(user):
        return getattr(user, "company", None)

    # ---- Superadmin : on lit d'abord le GET (string) puis la session (int) ----
    raw_cid = request.GET.get("company")
    if isinstance(raw_cid, str):
        raw_cid = raw_cid.strip()
    if not raw_cid:
        raw_cid = request.session.get("dash_company_id")  # peut être un int

    # On résout l'entreprise (Django accepte int/str pour pk)
    company = Company.objects.filter(pk=raw_cid).first() if raw_cid else None
    if company:
        request.session["dash_company_id"] = company.id  # on stocke proprement l'int
        return company

    # Fallback : 1ʳᵉ entreprise (si autorisé)
    if allow_default_for_superadmin:
        company = Company.objects.order_by("name").first()
        if company:
            request.session["dash_company_id"] = company.id
        return company

    return None


def _can_manage_company(user, company) -> bool:
    return _is_superadmin(user) or (getattr(user, "company_id", None) == company.id)


def ensure_reward_templates(company: Company):
    """
    Crée les 4 templates si manquants, avec probas affichées figées.
    (Utilisé pour un écran mono-entreprise : liste/édition des templates)
    """
    defaults_map = {
        "SOUVENT":   {"label": "- 10 % de remise", "cooldown_months": 1},
        "MOYEN":     {"label": "- 10 % de remise", "cooldown_months": 1},
        "RARE":      {"label": "iPhone 16 Pro Max", "cooldown_months": 3},
        "TRES_RARE": {"label": "Voyage à Miami", "cooldown_months": 6},
    }
    for key, ui in BUCKET_UI.items():
        obj, _created = RewardTemplate.objects.get_or_create(
            company=company, bucket=key,
            defaults={
                **defaults_map[key],
                "probability_display": ui["prob"],
                "min_referrals_required": 0,
            }
        )
        if not obj.probability_display:
            obj.probability_display = ui["prob"]
            obj.save(update_fields=["probability_display"])


def _last_12_month_starts(today):
    """
    Retourne la liste des 12 premiers jours de mois (du plus ancien au plus récent).
    """
    y, m = today.year, today.month
    out = []
    for i in range(11, -1, -1):
        yy, mm = y, m - i
        while mm <= 0:
            mm += 12
            yy -= 1
        out.append(date(yy, mm, 1))
    return out


# ----------------------------- Snapshot des roues (local) -----------------------------
# Clés/tokens alignés avec rewards/probabilities.py
_BASE_KEY = "base_100"
_VERY_RARE_KEY = "very_rare_10000"

_TOK_BASE = ["SOUVENT", "MOYEN", "RARE"]
_TOK_VR   = ["TRES_RARE", "NO_HIT"]


def _remaining_counts(pool, idx, tokens):
    """Compte ce qu'il reste AVANT la fin du cycle actuel (de idx -> fin)."""
    tail = pool[idx:] if pool and 0 <= idx < len(pool) else pool
    out = {}
    for t in tokens:
        out[t] = tail.count(t) if tail else 0
    return out


def _wheels_snapshot(company: Company):
    """
    Renvoie un dict:
    {
      "base":      {"size": int, "idx": int, "progress_pct": int,
                    "remaining_by_token": {token: n}, "total_by_token": {token: n}},
      "very_rare": { ... }
    }
    Si une roue n'existe pas encore, on renvoie des zéros élégants.
    """
    snap = {}
    # --- BASE ---
    try:
        base = ProbabilityWheel.objects.get(company=company, key=_BASE_KEY)
        base_total = {t: base.pool.count(t) for t in _TOK_BASE}
        base_remaining = _remaining_counts(base.pool, base.idx, _TOK_BASE)
        base_progress = int((base.idx / base.size) * 100) if base.size else 0
        snap["base"] = {
            "size": base.size,
            "idx": base.idx,
            "progress_pct": base_progress,
            "remaining_by_token": base_remaining,
            "total_by_token": base_total,
        }
    except ProbabilityWheel.DoesNotExist:
        snap["base"] = {
            "size": 0,
            "idx": 0,
            "progress_pct": 0,
            "remaining_by_token": {t: 0 for t in _TOK_BASE},
            "total_by_token": {t: 0 for t in _TOK_BASE},
        }

    # --- VERY RARE ---
    try:
        vr = ProbabilityWheel.objects.get(company=company, key=_VERY_RARE_KEY)
        vr_total = {t: vr.pool.count(t) for t in _TOK_VR}
        vr_remaining = _remaining_counts(vr.pool, vr.idx, _TOK_VR)
        vr_progress = int((vr.idx / vr.size) * 100) if vr.size else 0
        snap["very_rare"] = {
            "size": vr.size,
            "idx": vr.idx,
            "progress_pct": vr_progress,
            "remaining_by_token": vr_remaining,
            "total_by_token": vr_total,
        }
    except ProbabilityWheel.DoesNotExist:
        snap["very_rare"] = {
            "size": 0,
            "idx": 0,
            "progress_pct": 0,
            "remaining_by_token": {t: 0 for t in _TOK_VR},
            "total_by_token": {t: 0 for t in _TOK_VR},
        }

    return snap


# ----------------------------- CRUD Templates -----------------------------

@login_required
def reward_list(request):
    """
    Écran de gestion des templates de récompenses.
    - Admin/Opérateur : sur son entreprise.
    - Superadmin : PAS de choix requis → on prend automatiquement la 1ʳᵉ entreprise
      (ou celle passée en ?company=... si présent).
    """
    company = _current_company(request, allow_default_for_superadmin=True)
    if not company:
        # Cas extrême : aucune entreprise en base
        messages.info(request, "Aucune entreprise disponible.")
        return render(request, "rewards/list.html", {"items": [], "TEST_WHEEL": None, "company": None})

    # S’assure que les 4 templates existent pour cette entreprise (mono-contexte)
    ensure_reward_templates(company)

    # 1) Récupérer les templates
    qs = RewardTemplate.objects.filter(company=company)

    # 2) Trier par bucket (SOUVENT -> MOYEN -> RARE -> TRES_RARE)
    order = {"SOUVENT": 0, "MOYEN": 1, "RARE": 2, "TRES_RARE": 3}
    items_sorted = sorted(qs, key=lambda tpl: order.get(tpl.bucket, 99))

    # 3) Préparer l'affichage (paire (template, ui))
    items = [(tpl, BUCKET_UI[tpl.bucket]) for tpl in items_sorted]

    # 4) Données de la roue de test (probas identiques à Reward)
    test_wheel = {
        "base": {"size": BASE_SIZE, "counts": BASE_COUNTS},
        "very_rare": {"size": VR_SIZE, "counts": VR_COUNTS},
    }

    return render(request, "rewards/list.html", {
        "company": company,
        "items": items,
        "TEST_WHEEL": test_wheel,
        "is_superadmin": _is_superadmin(request.user),
    })


@login_required
def reward_update(request, pk):
    company = _current_company(request, allow_default_for_superadmin=True)
    r = get_object_or_404(RewardTemplate, pk=pk, company=company)
    if request.method == "POST":
        form = RewardTemplateForm(request.POST, instance=r)
        if form.is_valid():
            form.save()
            messages.success(request, "Récompense mise à jour.")
            return redirect("rewards:list")
    else:
        form = RewardTemplateForm(instance=r)
    return render(request, "rewards/form.html", {"form": form, "tpl": r, "ui": BUCKET_UI[r.bucket], "company": company})


# ------------------------------ Historique (entreprise / global) ------------------------------

@login_required
def rewards_history_company(request):
    """
    Historique des récompenses.
    - Superadmin SANS ?company=… : historique GLOBAL (toutes entreprises).
    - Sinon : historique filtré par entreprise.
    """
    user = request.user

    base_qs = (
        Reward.objects
        .select_related("company", "client", "referral", "referral__referrer", "referral__referee")
        .order_by("-created_at", "-id")
    )

    # ---- Global si Superadmin sans paramètre ----
    if _is_superadmin(user) and not request.GET.get("company"):
        qs = base_qs
        company = None
        scope_label = "GLOBAL"
    else:
        company = _current_company(request)  # comportement existant conservé
        if not company:
            messages.error(request, "Aucune entreprise sélectionnée.")
            return redirect("dashboard:root")
        qs = base_qs.filter(company=company)
        scope_label = company.name

    # Filtres UI
    bucket = (request.GET.get("bucket") or "").strip().upper()
    state  = (request.GET.get("state") or "").strip().upper()
    q      = (request.GET.get("q") or "").strip()

    if bucket in BUCKET_UI:
        qs = qs.filter(bucket=bucket)
    if state in STATE_UI:
        qs = qs.filter(state=state)
    if q:
        qs = qs.filter(
            Q(client__first_name__icontains=q) |
            Q(client__last_name__icontains=q)  |
            Q(client__email__icontains=q)      |
            Q(label__icontains=q)
        )

    page = Paginator(qs, 20).get_page(request.GET.get("p"))

    return render(request, "rewards/history.html", {
        "company": company,                # None en mode global
        "scope_label": scope_label,        # "GLOBAL" ou nom d’entreprise
        "page": page,
        "bucket": bucket,
        "state": state,
        "q": q,
        "BUCKET_UI": BUCKET_UI,
        "STATE_UI": STATE_UI,
        "buckets": [(k, v["label"]) for k, v in BUCKET_UI.items()],
        "states": [(k, v["label"]) for k, v in STATE_UI.items()],
        "is_superadmin": _is_superadmin(user),
    })

# ------------------------------ Spin (animation) ------------------------------

@login_required
def reward_spin(request, reward_id: int):
    reward = get_object_or_404(
        Reward.objects.select_related("company", "client"),
        pk=reward_id
    )

    wheel_order = ["SOUVENT", "MOYEN", "RARE", "TRES_RARE"]
    segment = 360 / len(wheel_order)  # 90°
    try:
        idx = wheel_order.index(reward.bucket)
    except ValueError:
        idx = 0
    target_angle = 4 * 360 + int(idx * segment + segment / 2)

    ui = BUCKET_UI.get(reward.bucket, {"label": reward.bucket, "badge": "secondary"})
    return render(request, "rewards/spin.html", {
        "reward": reward,
        "ui": ui,
        "target_angle": target_angle,
    })


# ------------------------------ Page publique (token) ------------------------------

def use_reward(request, token):
    """
    Page publique d'une récompense (par token) avec un rendu "joli".
    AUCUN changement de logique métier : on enrichit juste le contexte.
    """
    reward = get_object_or_404(
        Reward.objects.select_related(
            "company", "client", "referral", "referral__referrer", "referral__referee"
        ),
        token=token,
    )

    # Message informatif si la récompense n'est plus en attente
    if reward.state != "PENDING":
        messages.info(
            request,
            "Cette récompense n’est plus en attente (déjà distribuée ou inactive)."
        )

    # Données d'en-tête
    company_name = (getattr(reward.company, "name", "") or "").strip()
    client_name  = (reward.client.first_name or reward.client.last_name or "").strip()

    # Si la récompense provient d'un parrainage, on personnalise :
    is_ref = bool(reward.referral_id)
    is_referrer = is_ref and reward.client_id == reward.referral.referrer_id
    is_referee  = is_ref and reward.client_id == reward.referral.referee_id

    referrer_name = ""
    referee_name  = ""
    if is_ref:
        referrer_name = (reward.referral.referrer.first_name or reward.referral.referrer.last_name or "").strip()
        referee_name  = (reward.referral.referee.first_name  or reward.referral.referee.last_name  or "").strip()

    # Phrases d'accroche (comme sur la maquette)
    if is_referrer:
        headline  = f"Félicitations {client_name} !" if client_name else "Félicitations !"
        celebrate = f"Tu as fait découvrir {company_name} à {referee_name}".strip()
        subline   = "Voici ton cadeau 🎁"
        ribbon    = f"Parrainage validé grâce à {referee_name}".strip()
    elif is_referee:
        headline  = f"Bienvenue {client_name} !" if client_name else "Bienvenue !"
        celebrate = f"Parrainage validé grâce à {referrer_name}".strip()
        subline   = "Voici ton cadeau 🎁"
        ribbon    = "Ton cadeau"
    else:
        headline  = f"Félicitations {client_name} !" if client_name else "Félicitations !"
        celebrate = company_name
        subline   = "Voici ton cadeau 🎁"
        ribbon    = "Ton cadeau"

    claim_absolute = request.build_absolute_uri(reward.claim_path) if reward.claim_path else ""

    context = {
        "reward": reward,
        "headline": headline,
        "celebrate": celebrate,
        "subline": subline,
        "ribbon": ribbon,
        "company_name": company_name,
        "claim_absolute": claim_absolute,
    }
    return render(request, "rewards/use_reward.html", context)


# ------------------------------ Actions ------------------------------

@login_required
@require_POST
def distribute_reward(request, pk: int):
    reward = get_object_or_404(
        Reward.objects.select_related("company", "client"),
        pk=pk
    )

    if not _can_manage_company(request.user, reward.company):
        messages.error(request, "Accès refusé.")
        back_id = request.POST.get("back_client")
        return redirect("dashboard:client_detail", pk=back_id) if back_id else redirect("dashboard:clients_list")

    if reward.state != "PENDING":
        messages.info(request, "La récompense n’est pas en attente (déjà traitée ?).")
    else:
        reward.state = "SENT"
        reward.redeemed_at = timezone.now()
        reward.save(update_fields=["state", "redeemed_at"])
        messages.success(request, f"Récompense « {reward.label} » distribuée.")

    back_id = request.POST.get("back_client")
    return redirect("dashboard:client_detail", pk=back_id) if back_id else redirect("rewards:history_company")


@login_required
@require_POST
def referral_delete(request, pk: int):
    referral = get_object_or_404(
        Referral.objects.select_related("company", "referrer", "referee"),
        pk=pk
    )

    if not _can_manage_company(request.user, referral.company):
        messages.error(request, "Accès refusé.")
        back_id = request.POST.get("back_client")
        return redirect("dashboard:client_detail", pk=back_id) if back_id else redirect("dashboard:clients_list")

    back_client_id = request.POST.get("back_client") or referral.referee_id or referral.referrer_id

    referral.delete()
    messages.success(request, "Parrainage supprimé.")
    return redirect("dashboard:client_detail", pk=back_client_id)


# ------------------------------ STATS (récompenses) ------------------------------

@login_required
def rewards_stats(request):
    """
    Superadmin sans ?company=... => stats GLOBAL (toutes entreprises)
    Sinon => stats bornées à l’entreprise courante.
    """
    user = request.user

    # ---- Superadmin GLOBAL (on n'utilise pas _current_company ici) ----
    if _is_superadmin(user) and not request.GET.get("company"):
        # Période (4 derniers mois)
        def _last_n_month_starts(today, n):
            y, m = today.year, today.month
            out = []
            for i in range(n - 1, -1, -1):
                yy, mm = y, m - i
                while mm <= 0:
                    mm += 12
                    yy -= 1
                out.append(date(yy, mm, 1))
            return out

        today = timezone.now().date().replace(day=1)
        months = _last_n_month_starts(today, 4)

        qs_all = Reward.objects.all()

        monthly_raw = (
            qs_all.annotate(m=TruncMonth("created_at"))
                  .values("m").annotate(n=Count("id")).order_by("m")
        )
        monthly_map = {row["m"].date(): row["n"] for row in monthly_raw if row["m"]}
        monthly_rows = [{"month": m, "n": monthly_map.get(m, 0)} for m in months]
        max_n = max([r["n"] for r in monthly_rows] or [1])
        for r in monthly_rows:
            r["pct"] = int((r["n"] / max_n) * 100) if max_n else 0

        gifts_raw = list(qs_all.values("label").annotate(n=Count("id")).order_by("-n")[:4])
        total_gifts = sum(g["n"] for g in gifts_raw) or 1
        top_gifts = [
            {"label": g["label"] or "—", "n": g["n"], "pct": int((g["n"] / total_gifts) * 100)}
            for g in gifts_raw
        ]

        # KPI + tableau par entreprise
        rows = []
        totals = {"rewards_sent": 0, "rewards_pending": 0, "clients": 0, "referrals_month": 0}
        month_start = timezone.now().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        for c in Company.objects.all().order_by("name"):
            r_sent = Reward.objects.filter(company=c, state="SENT").count()
            r_pend = Reward.objects.filter(company=c, state="PENDING").count()
            n_clients = c.client_set.count() if hasattr(c, "client_set") else 0
            n_ref_month = Referral.objects.filter(company=c, created_at__gte=month_start).count()
            rows.append({
                "company": c,
                "rewards_sent": r_sent,
                "rewards_pending": r_pend,
                "clients": n_clients,
                "referrals_month": n_ref_month,
            })
            totals["rewards_sent"] += r_sent
            totals["rewards_pending"] += r_pend
            totals["clients"] += n_clients
            totals["referrals_month"] += n_ref_month

        return render(request, "rewards/stats.html", {
            "company": None,              # important : pas d’entreprise sélectionnée
            "is_superadmin": True,
            "monthly_rows": monthly_rows,
            "top_gifts": top_gifts,
            "global_rows": rows,          # tableau par entreprise
            "global_kpi": totals,         # totaux globaux
        })

    # ---- Entreprise (Admin/Opérateur OU Superadmin avec ?company=...) ----
    company = _current_company(request)  # comportement existant conservé
    if not company:
        messages.error(request, "Aucune entreprise sélectionnée.")
        return redirect("dashboard:root")

    qs = Reward.objects.filter(company=company)

    # 4 derniers mois
    def _last_n_month_starts(today, n):
        y, m = today.year, today.month
        out = []
        for i in range(n - 1, -1, -1):
            yy, mm = y, m - i
            while mm <= 0:
                mm += 12
                yy -= 1
            out.append(date(yy, mm, 1))
        return out

    today = timezone.now().date().replace(day=1)
    months = _last_n_month_starts(today, 4)

    monthly_raw = (
        qs.annotate(m=TruncMonth("created_at"))
          .values("m").annotate(n=Count("id")).order_by("m")
    )
    monthly_map = {row["m"].date(): row["n"] for row in monthly_raw if row["m"]}
    monthly_rows = [{"month": m, "n": monthly_map.get(m, 0)} for m in months]
    max_n = max([r["n"] for r in monthly_rows] or [1])
    for r in monthly_rows:
        r["pct"] = int((r["n"] / max_n) * 100) if max_n else 0

    gifts_raw = list(qs.values("label").annotate(n=Count("id")).order_by("-n")[:4])
    total_gifts = sum(g["n"] for g in gifts_raw) or 1
    top_gifts = [
        {"label": g["label"] or "—", "n": g["n"], "pct": int((g["n"] / total_gifts) * 100)}
        for g in gifts_raw
    ]

    return render(request, "rewards/stats.html", {
        "company": company,
        "is_superadmin": _is_superadmin(user),
        "monthly_rows": monthly_rows,
        "top_gifts": top_gifts,
    })


# ------------------------------ Roue de test (sans attribution) ------------------------------

@login_required
def test_wheel(request):
    """
    Roue de test (sans attribution).

    Probabilités « de base » (sans minimums) :
      - SOUVENT   = 80 / 100
      - MOYEN     = 19 / 100
      - RARE      = 0,99999 / 100
      - TRES_RARE = 1 / 100000

    Modes :
      - combined (défaut) : test TRES_RARE (1/100000), sinon base 80/19/~1%
      - base              : uniquement SOUVENT/MOYEN/RARE
      - very_rare         : TRES_RARE vs NO_HIT
    GET:
      - n    : simuler N tirages
      - seed : graine RNG (reproductible)
      - mode : combined | base | very_rare
    """
    mode = (request.GET.get("mode") or "combined").lower()
    simulate_n = int(request.GET.get("n") or 0)
    seed = request.GET.get("seed")
    rng = random.Random(seed) if seed else random

    # Probabilités demandées
    P_S  = Decimal("80") / Decimal("100")        # 0.80
    P_M  = Decimal("19") / Decimal("100")        # 0.19
    P_R  = Decimal("0.99999") / Decimal("100")   # 0.0099999
    P_TR = Decimal(1) / Decimal(100000)          # 0.00001

    ORDER = ("SOUVENT", "MOYEN", "RARE", "TRES_RARE", "NO_HIT")

    # ---- Tirage 1 coup (pour l’animation) : pondération simple ----
    def weighted_choice(weights: dict[str, Decimal]) -> str:
        total = float(sum(weights.values())) or 1.0
        x = rng.random() * total
        acc = 0.0
        for k in ORDER:
            if k in weights:
                acc += float(weights[k])
                if x < acc:
                    return k
        return next(iter(weights))

    def draw_once() -> str:
        if mode == "very_rare":
            return weighted_choice({"TRES_RARE": P_TR, "NO_HIT": Decimal(1) - P_TR})
        if mode == "base":
            return weighted_choice({"SOUVENT": P_S, "MOYEN": P_M, "RARE": P_R})
        # combined
        if rng.random() < float(P_TR):
            return "TRES_RARE"
        return weighted_choice({"SOUVENT": P_S, "MOYEN": P_M, "RARE": P_R})

    bucket = draw_once()

    # ---- Simulation N tirages (sans remise pour respecter 80/19/1 sur 100) ----
    counts = pct = None
    if simulate_n > 0:
        counts = {"SOUVENT": 0, "MOYEN": 0, "RARE": 0, "TRES_RARE": 0, "NO_HIT": 0}

        if mode == "very_rare":
            # N essais indépendants de proba 1/100000
            for _ in range(simulate_n):
                if rng.random() < float(P_TR):
                    counts["TRES_RARE"] += 1
                else:
                    counts["NO_HIT"] += 1

        else:
            # Base « exacte » : cycles de 100 cases (80/19/1), échantillonnage sans remise.
            full_cycles, rem = divmod(simulate_n, 100)
            counts["SOUVENT"] += 80 * full_cycles
            counts["MOYEN"]   += 19 * full_cycles
            counts["RARE"]    += 1  * full_cycles

            if rem:
                base_pool = ["SOUVENT"] * 80 + ["MOYEN"] * 19 + ["RARE"] * 1
                rng.shuffle(base_pool)
                for t in base_pool[:rem]:
                    counts[t] += 1

            if mode == "combined":
                # Injecte les très rares (très improbable sur 100 tirages)
                # On convertit autant de tirages base en TRES_RARE pour rester à N total.
                vr_hits = sum(1 for _ in range(simulate_n) if rng.random() < float(P_TR))
                for _ in range(vr_hits):
                    base_list = (
                        ["SOUVENT"] * counts["SOUVENT"] +
                        ["MOYEN"]   * counts["MOYEN"]   +
                        ["RARE"]    * counts["RARE"]
                    )
                    if base_list:
                        t = rng.choice(base_list)
                        counts[t] -= 1
                    counts["TRES_RARE"] += 1

        total = sum(counts.values()) or 1
        pct = {k: round(counts[k] * 100 / total, 2) for k in counts}

    # ---- UI / animation ----
    ui = BUCKET_UI.get(bucket, {"label": "Aucun gain", "badge": "secondary"})
    wheel_order = ["SOUVENT", "MOYEN", "RARE", "TRES_RARE"]
    seg = 360 / len(wheel_order)
    idx = wheel_order.index(bucket) if bucket in wheel_order else 0
    target_angle = 4 * 360 + int(idx * seg + seg / 2)

    return render(request, "rewards/test_wheel.html", {
        "bucket": bucket,
        "ui": ui,
        "target_angle": target_angle,
        "mode": mode,
        "seed": seed or "",
        "simulate_n": simulate_n,
        "counts": counts,
        "pct": pct,
    })


# ------------------------------ Envoi SMS lien de récompense ------------------------------

@login_required
@require_POST
def reward_send_sms(request, pk: int):
    """
    Envoie au client un SMS contenant le lien d’utilisation de la récompense (token).
    POST /rewards/<pk>/send/sms/
    """
    reward = get_object_or_404(Reward.objects.select_related("client", "company"), pk=pk)

    # --- Permissions (mêmes règles que distribute_reward) ---
    user = request.user
    if _is_superadmin(user):
        pass
    elif getattr(user, "company_id", None) and reward.company_id == user.company_id:
        pass
    else:
        raise Http404("Non autorisé")

    # Génère un token s’il n’existe pas encore (pour construire l’URL)
    reward.ensure_token()
    reward.save(update_fields=["token", "token_expires_at"])

    # Données pour le SMS
    claim_absolute = request.build_absolute_uri(reward.claim_path)
    client_fullname = f"{reward.client.first_name} {reward.client.last_name}".strip()
    company_name = getattr(reward.company, "name", None)

    phone = normalize_msisdn(reward.client.phone or "")
    if not phone:
        messages.error(request, "Le client n’a pas de numéro de téléphone valide.")
        back_id = request.POST.get("back_client")
        return redirect("dashboard:client_detail", pk=back_id) if back_id else redirect("dashboard:clients_list")

    text = build_reward_sms_text(
        client_fullname=client_fullname,
        claim_absolute_url=claim_absolute,
        company_name=company_name,
    )

    payload = SMSPayload(to=phone, text=text, sender=settings.SMSMODE.get("SENDER") or None)
    result = send_sms(payload)

    if result.ok:
        messages.success(request, "SMS envoyé au client.")
    else:
        messages.error(request, f"Échec d’envoi SMS ({result.status}).")

    back_id = request.POST.get("back_client")
    return redirect("dashboard:client_detail", pk=back_id) if back_id else redirect("rewards:history_company")
===== ./templates/rewards/form.html =====
{# templates/rewards/form.html #}
{% extends "base_dashboard.html" %}
{% block title %}Modifier une récompense • ParrainApp{% endblock %}
{% block body_data_page %}recompenses{% endblock %}

{% block content %}
<header class="mb-3">
  <h1 class="h4 section-title mb-1">Modifier « {{ tpl.label }} » ({{ ui.label }})</h1>
  <div class="text-secondary">Probabilité : ~{{ tpl.probability_display }} (fixe)</div>
</header>

<div class="card shadow-sm">
  <form method="post" class="card-body vstack gap-3">
    {% csrf_token %}

    <div class="row g-3">
      <div class="col-md-6">
        <label for="{{ form.label.id_for_label }}" class="form-label">Nom de la récompense</label>
        {{ form.label }}
      </div>

      <div class="col-md-3">
        <label for="{{ form.cooldown_months.id_for_label }}" class="form-label">Délai</label>
        {{ form.cooldown_months }}
      </div>

      <div class="col-md-3">
        <label for="{{ form.min_referrals_required.id_for_label }}" class="form-label">
          Minimum de parrainages requis
        </label>
        {{ form.min_referrals_required }}
        <div class="form-text">0 = aucun minimum.</div>
      </div>
    </div>

    <div class="d-flex justify-content-end gap-2 mt-3">
      <a href="{% url 'rewards:list' %}" class="btn btn-outline-secondary">Annuler</a>
      <button type="submit" class="btn btn-primary">Enregistrer</button>
    </div>
  </form>
</div>
{% endblock %}
===== ./templates/rewards/wheels.html =====
{# templates/rewards/wheels.html #}
{% extends "base_dashboard.html" %}
{% block title %}Roue de probabilités • ParrainApp{% endblock %}
{% block body_data_page %}recompenses{% endblock %}

{% block content %}

{# Mini override pour “orange” Bootstrap (Rare) #}
<style>
  .text-bg-orange{color:#fff!important;background-color:#fd7e14!important}
  .bg-orange-subtle{background-color:rgba(253,126,20,.15)!important}
</style>

<header class="mb-4">
  <h1 class="h4 section-title mb-1">Roue de probabilités</h1>
  <div class="text-secondary">Exactement 80/100, 19/100, 1/100 et 1/10000 par entreprise.</div>
</header>

<div class="d-flex justify-content-end mb-3">
  {# même placement que “Ajouter une récompense” dans ta maquette #}
  <form method="post" action="{% url 'rewards:wheel_rebuild' base_key %}" class="me-2">
    {% csrf_token %}
    <button class="btn btn-outline-primary">Régénérer base (100)</button>
  </form>
  <form method="post" action="{% url 'rewards:wheel_rebuild' vr_key %}">
    {% csrf_token %}
    <button class="btn btn-outline-danger">Régénérer très rare (10 000)</button>
  </form>
</div>

<div class="row g-3">
  {# On reprend exactement la grille de 4 cards #}
  {% for c in cards %}
  <div class="col-md-6 col-xl-3">
    <div class="card h-100 shadow-sm">
      <div class="card-header d-flex justify-content-between
           {% if c.code == 'souvent' %}bg-success-subtle
           {% elif c.code == 'moyen' %}bg-warning-subtle
           {% elif c.code == 'rare' %}bg-orange-subtle
           {% else %}bg-danger-subtle
           {% endif %}">
        <span class="badge {{ c.badge_cl }}">{{ c.title }}</span>
        <small class="text-secondary">{{ c.approx }}</small>
      </div>
      <div class="card-body d-flex flex-column">
        <h3 class="h6">{{ c.title }} — restants dans le cycle : {{ c.remaining }} / {{ c.total }}</h3>
        <div class="text-secondary small mb-3">
          Curseur de la roue :
          <strong>{{ c.progress }}%</strong>
        </div>

        <div class="progress mb-3" style="height:6px">
          <div class="progress-bar" style="width: {{ c.progress }}%"></div>
        </div>

        <div class="mt-auto d-flex flex-wrap gap-2">
          {% if c.code in 'souvent,moyen,rare' %}
            <form method="post" action="{% url 'rewards:wheel_reset' base_key %}">
              {% csrf_token %}<button class="btn btn-sm btn-outline-secondary">Remettre à zéro (base)</button>
            </form>
            <form method="post" action="{% url 'rewards:wheel_consume' base_key %}">
              {% csrf_token %}<button class="btn btn-sm btn-outline-primary">Consommer 1 tirage (test)</button>
            </form>
          {% else %}
            <form method="post" action="{% url 'rewards:wheel_reset' vr_key %}">
              {% csrf_token %}<button class="btn btn-sm btn-outline-secondary">Remettre à zéro (très rare)</button>
            </form>
            <form method="post" action="{% url 'rewards:wheel_consume' vr_key %}">
              {% csrf_token %}<button class="btn btn-sm btn-outline-primary">Consommer 1 tirage (test)</button>
            </form>
          {% endif %}
        </div>
      </div>
    </div>
  </div>
  {% endfor %}
</div>

{% endblock %}
===== ./templates/rewards/spin.html =====
{% extends "base_dashboard.html" %}
{% block title %}Roulette de récompense • ParrainApp{% endblock %}
{% block body_data_page %}recompenses{% endblock %}

{% block content %}
<style>
/* --------- Variables de teinte ---------- */
.wheel {
  --accent: #6c757d; /* fallback */
  width: 300px; height: 300px;
  border-radius: 50%;
  border: 8px solid var(--accent);
  position: relative;
  margin: 0 auto;
  box-shadow:
    0 0 0 4px rgba(0,0,0,.03),
    0 0 30px rgba(0,0,0,.06) inset;
  transition: box-shadow .3s ease, border-color .3s ease;
}
.wheel.is-spinning { box-shadow: 0 0 0 4px rgba(0,0,0,.03), 0 0 46px var(--accent); }

/* Aiguille (triangle en haut) */
.wheel::after{
  content:"";
  position:absolute; top:-20px; left:50%; transform:translateX(-50%);
  width:0; height:0;
  border-left: 12px solid transparent;
  border-right:12px solid transparent;
  border-bottom:22px solid var(--accent);
  filter: drop-shadow(0 2px 0 rgba(0,0,0,.15));
}

/* Disque interne : conic-gradient 4 segments dans l’ordre SOUVENT/MOYEN/RARE/TRES_RARE */
.wheel__disk{
  position:absolute; inset: 16px;
  border-radius:50%;
  background:
    conic-gradient(
      rgba(25,135,84,.90) 0deg,   rgba(25,135,84,.90) 90deg,   /* success  -> SOUVENT */
      rgba(13,202,240,.90) 90deg, rgba(13,202,240,.90) 180deg, /* info     -> MOYEN   */
      rgba(253,126,20,.92) 180deg,rgba(253,126,20,.92) 270deg, /* orange   -> RARE    */
      rgba(220,53,69,.92) 270deg, rgba(220,53,69,.92) 360deg   /* danger   -> TRES_RARE */
    );
  transform-origin:50% 50%;
}

/* Animation de rotation */
.spin-anim { transition: transform 2.2s cubic-bezier(.17,.67,.13,1.02); }

/* Map badge -> couleur d’accent */
.wheel--success { --accent:#198754; } /* vert   */
.wheel--info    { --accent:#0dcaf0; } /* bleu   */
.wheel--warning { --accent:#fd7e14; } /* orange */
.wheel--danger  { --accent:#dc3545; } /* rouge  */

/* Carte résultat */
.result-card { border-left: 4px solid var(--accent); }
</style>

<header class="mb-4 d-flex justify-content-between align-items-center">
  <div>
    <h1 class="h5 mb-1">Animation de la roue</h1>
    <div class="text-secondary">
      Récompense attribuée à <strong>{{ reward.client.last_name }} {{ reward.client.first_name }}</strong>
    </div>
  </div>
  <a class="btn btn-outline-secondary" href="{% url 'dashboard:client_detail' pk=reward.client_id %}">Retour fiche client</a>
</header>

<div class="card shadow-sm">
  <div class="card-body d-flex flex-column align-items-center">
    {# La classe wheel--{{ ui.badge }} pose la bonne couleur (success/info/warning/danger) #}
    <div class="wheel wheel--{{ ui.badge }} is-spinning">
      <div id="disk" class="wheel__disk spin-anim"></div>
    </div>

    <div class="mt-4 text-center result-card px-3 py-2 rounded">
      <span class="badge text-bg-{{ ui.badge }} me-2">{{ ui.label }}</span>
      <strong id="rewardLabel">{{ reward.label }}</strong>
    </div>
  </div>
</div>

<script>
(function(){
  const disk = document.getElementById('disk');
  const target = {{ target_angle|default:1440 }};
  // Lance la rotation après un mini délai pour laisser le layout se peindre
  setTimeout(()=>{ disk.style.transform = `rotate(${target}deg)`; }, 60);
  // Retire l'état “is-spinning” une fois l’animation finie (effet de lueur)
  disk.addEventListener('transitionend', () => {
    const wheel = disk.closest('.wheel');
    wheel && wheel.classList.remove('is-spinning');
  }, { once: true });
})();
</script>
{% endblock %}
===== ./templates/rewards/stats.html =====
{# templates/rewards/stats.html #}
{% extends "base_dashboard.html" %}
{% load static %}
{% block title %}Statistiques • Récompenses{% endblock %}
{% block body_data_page %}stats{% endblock %}
{% block nav_rewards_active %}active{% endblock %}

{% block content %}
<header class="mb-4">
  {% if company %}
    <h1 class="h4 section-title mb-1">Statistiques — {{ company.name }}</h1>
    <div class="text-secondary">Vue des récompenses pour cette entreprise.</div>
  {% elif is_superadmin %}
    <h1 class="h4 section-title mb-1">Statistiques — Global (Superadmin)</h1>
    <div class="text-secondary">Vue d’ensemble sur l’ensemble des entreprises.</div>
  {% else %}
    <h1 class="h4 section-title mb-1">Statistiques</h1>
  {% endif %}
</header>

{# ===== KPI globaux (uniquement si global_kpi est fourni) ===== #}
{% if global_kpi %}
<div class="row g-3 mb-3">
  <div class="col-12 col-md-6 col-xl-3">
    <div class="card h-100 shadow-sm"><div class="card-body">
      <div class="text-secondary small">Parrainages (mois)</div>
      <div class="stat-num">{{ global_kpi.referrals_month|default:0 }}</div>
    </div></div>
  </div>
  <div class="col-12 col-md-6 col-xl-3">
    <div class="card h-100 shadow-sm"><div class="card-body">
      <div class="text-secondary small">Cadeaux distribués</div>
      <div class="stat-num">{{ global_kpi.rewards_sent|default:0 }}</div>
    </div></div>
  </div>
  <div class="col-12 col-md-6 col-xl-3">
    <div class="card h-100 shadow-sm"><div class="card-body">
      <div class="text-secondary small">Cadeaux en attente</div>
      <div class="stat-num">{{ global_kpi.rewards_pending|default:0 }}</div>
    </div></div>
  </div>
  <div class="col-12 col-md-6 col-xl-3">
    <div class="card h-100 shadow-sm"><div class="card-body">
      <div class="text-secondary small">Base clients</div>
      <div class="stat-num">{{ global_kpi.clients|default:0 }}</div>
    </div></div>
  </div>
</div>
{% endif %}

{# ===== 2 visuels communs (mensuel + top cadeaux) ===== #}
<div class="row g-3 mb-3">
  <div class="col-lg-7">
    <div class="card h-100 shadow-sm">
      <div class="card-header d-flex justify-content-between align-items-center">
        <div class="fw-semibold">Récompenses créées — 4 derniers mois</div>
        <small class="text-secondary">Volume par mois</small>
      </div>
      <div class="card-body">
        {% if monthly_rows %}
          <ul class="list-group list-group-flush">
            {% for r in monthly_rows %}
            <li class="list-group-item">
              <div class="d-flex justify-content-between mb-1">
                <span class="small text-secondary">{{ r.month|date:"M Y" }}</span>
                <span class="small">{{ r.n }}</span>
              </div>
              <div class="progress" role="progressbar" aria-valuenow="{{ r.pct }}" aria-valuemin="0" aria-valuemax="100">
                <div class="progress-bar" style="width: {{ r.pct }}%"></div>
              </div>
            </li>
            {% endfor %}
          </ul>
        {% else %}
          <div class="text-secondary">Pas encore de données.</div>
        {% endif %}
      </div>
    </div>
  </div>

  <div class="col-lg-5">
    <div class="card h-100 shadow-sm">
      <div class="card-header d-flex justify-content-between align-items-center">
        <div class="fw-semibold">Top cadeaux</div>
        <small class="text-secondary">Part en %</small>
      </div>
      <div class="card-body">
        {% if top_gifts %}
          <ul class="list-group list-group-flush">
            {% for g in top_gifts %}
            <li class="list-group-item">
              <div class="d-flex justify-content-between mb-1">
                <span class="small">{{ g.label }}</span>
                <span class="small">{{ g.n }} — {{ g.pct }}%</span>
              </div>
              <div class="progress" role="progressbar" aria-valuenow="{{ g.pct }}" aria-valuemin="0" aria-valuemax="100">
                <div class="progress-bar" style="width: {{ g.pct }}%"></div>
              </div>
            </li>
            {% endfor %}
          </ul>
        {% else %}
          <div class="text-secondary">Pas de cadeaux enregistrés.</div>
        {% endif %}
      </div>
    </div>
  </div>
</div>

{# ===== Détail par entreprise (uniquement en mode global Superadmin) ===== #}
{% comment %} {% if global_rows %}
<div class="card shadow-sm">
  <div class="card-header d-flex justify-content-between align-items-center">
    <div class="fw-semibold">Détail par entreprise</div>
    <small class="text-secondary">Parrainages du mois, cadeaux et base clients</small>
  </div>
  <div class="card-body p-0">
    <div class="table-responsive">
      <table class="table align-middle mb-0">
        <thead class="table-light">
          <tr>
            <th>Entreprise</th>
            <th class="text-end">Parrainages (mois)</th>
            <th class="text-end">Cadeaux distribués</th>
            <th class="text-end">Cadeaux en attente</th>
            <th class="text-end">Base clients</th>
            <th class="text-end">Actions</th>
          </tr>
        </thead>
        <tbody>
          {% for r in global_rows %}
          <tr>
            <td class="fw-semibold">{{ r.company.name }}</td>
            <td class="text-end">{{ r.referrals_month }}</td>
            <td class="text-end"><span class="badge text-bg-success">{{ r.rewards_sent }}</span></td>
            <td class="text-end"><span class="badge text-bg-warning">{{ r.rewards_pending }}</span></td>
            <td class="text-end">{{ r.clients }}</td>
            <td class="text-end">
              <div class="d-inline-flex flex-wrap gap-2">
                <a class="btn btn-sm btn-outline-primary"
                   href="{% url 'dashboard:company_home' %}?company={{ r.company.id }}">Tableau</a>
                <a class="btn btn-sm btn-outline-secondary"
                   href="{% url 'rewards:history_company' %}?company={{ r.company.id }}">Historique</a>
                <a class="btn btn-sm btn-outline-dark"
                   href="{% url 'rewards:stats' %}?company={{ r.company.id }}">Stats</a>
              </div>
            </td>
          </tr>
          {% empty %}
          <tr><td colspan="6" class="text-secondary p-3">Aucune entreprise.</td></tr>
          {% endfor %}
        </tbody>
      </table>
    </div>
  </div>
</div>
{% endif %} {% endcomment %}
{% endblock %}
===== ./templates/rewards/use_reward.html =====
{% load static %}
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{{ company_name|default:"Récompense" }}</title>
  <style>
    :root{
      --g1:#ff4d6d; --g2:#7b2cbf;
      --ink:#1e164b; --muted:#6b6b8a; --surface:#ffffff;
      --shadow: 0 10px 30px rgba(24,17,62,.15);
      --radius: 22px;
      --brand: var(--c1, #6c5ce7);
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:#f7f8fb;color:#1a1537;font-family: ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
    .hero{
      background:
        radial-gradient(1200px 400px at 10% -10%, rgba(255,255,255,.2), transparent),
        linear-gradient(135deg,var(--g1),var(--g2));
      color:#fff; text-align:center; padding:56px 16px 72px;
    }
    .hero h1{margin:0 0 8px; font-weight:900; letter-spacing:.3px; font-size: clamp(26px, 4.2vw, 48px);}
    .hero p{margin:0; opacity:.95; font-size: clamp(14px, 2.2vw, 20px);}

    /* Carte principale */
    .card{
      width:min(760px, calc(100% - 24px));
      margin:-40px auto 40px; background:var(--surface); border-radius:var(--radius);
      box-shadow:var(--shadow); overflow:hidden;
    }

    /* Head badges — mobile-first */
    .card-head{
      display:flex; align-items:center; justify-content:space-between;
      gap:.75rem; padding:18px 22px;
      background: linear-gradient(135deg, rgba(255,255,255,.6), rgba(255,255,255,.35));
      backdrop-filter: blur(6px);
    }
    .badge{
      display:inline-flex; align-items:center; gap:.5rem;
      border-radius:999px; padding:.5rem .9rem;
      font-weight:700; line-height:1; white-space:nowrap;
      box-shadow:0 6px 14px rgba(12,16,32,.12);
      border:1px solid transparent;
      max-width:100%;
      font-size:13px;
    }
    .chip-primary{
      background:#0b1020; color:#fff; border-color:#0b1020;
      box-shadow:0 6px 16px rgba(11,16,32,.28), 0 0 0 2px color-mix(in oklab, var(--brand) 25%, #ffffff);
    }
    .chip-emoji{ font-size:1.05em; }
    .chip-text{
      display:inline-block; overflow:hidden; text-overflow:ellipsis;
      max-width: min(78vw, 520px);
      font-size: clamp(12px, 3.4vw, 14px);
    }
    .badge-sec{ background:#eef2f7; color:#111827; font-weight:600; border-color:#e6ebf1; }
    .chip-secure::before{ content:"🔒"; margin-right:.35rem; }

    .card-body{padding:22px;}
    h2{margin:6px 0 14px; font-size:32px; letter-spacing:.2px}
    .muted{color:var(--muted); font-size:14px;}

    .panel{
      border:1px dashed #e5e6ef; padding:16px; border-radius:14px; background:#fbfbfe; color:#2a2942;
    }
    .row{display:flex; gap:14px; flex-wrap:wrap; margin-top:14px}
    .row > *{flex:1 1 220px}

    /* Lien à copier : FIX mobile */
    .codebox{
      display:flex; align-items:center; gap:10px;
      border:1px solid #ececf6; padding:12px 14px; border-radius:12px; background:#fff;
      width:100%; overflow:hidden;
    }
    .codebox .url{
      flex:1 1 0;                 /* ← prend tout l'espace dispo */
      min-width:0;                /* ← autorise l’ellipsis */
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .codebox .btn{
      flex:0 0 auto;              /* ← le bouton ne se compresse pas */
    }

    .btn{
      appearance:none; border:0; border-radius:12px; padding:12px 16px; font-weight:700; cursor:pointer;
      background:#0f1226; color:#fff; box-shadow:0 6px 16px rgba(15,18,38,.18);
    }
    .btn.secondary{background:#eef0f6; color:#1e1a3a; box-shadow:none;}
    .footer{ text-align:center; color:#8b8aa7; font-size:14px; padding-bottom:32px;}
    .link{color:#5843e3; text-decoration:none; font-weight:700}

    /* Responsive chips */
    @media (max-width: 480px){
      .card-head{ flex-wrap:wrap; }
      .chip-primary{ flex:1 1 100%; justify-content:center; padding:.65rem 1rem; }
      .badge-sec{ margin-left:auto; padding:.5rem .75rem; }
      .btn{ padding:12px 14px; }
    }
    @media (max-width: 360px){
      .chip-text{ max-width: 72vw; }
      .badge-sec{ font-size:.92rem; }
      .btn{ padding:10px 12px; font-size:13px; }
    }

    /* Dark mode */
    @media (prefers-color-scheme: dark){
      body{background:#0e0f17; color:#e9e8f3}
      .hero{color:#fff}
      .card{background:#131527}
      .card-head{background:rgba(255,255,255,.05)}
      .panel{background:#0f1020; border-color:#262842}
      .codebox{background:#0f1020; border-color:#262842}
      .btn.secondary{background:#1b1d37; color:#fff}
      .footer{color:#a7a6c2}
      .badge-sec{ background:#1b2130; color:#e8ecf6; border-color:#263146; }
    }
  </style>
</head>
<body>

  <section class="hero">
    <div style="font-size:28px; line-height:1">🎉</div>
    <h1>{{ headline }}</h1>
    {% if celebrate %}<p>{{ celebrate }}</p>{% endif %}
    {% if subline %}<p style="margin-top:8px; opacity:.85">{{ subline }}</p>{% endif %}
  </section>

  <!-- Carte -->
  <main class="card" role="main" aria-labelledby="gift-title">

    <!-- HEAD DESKTOP + MOBILE -->
    <div class="card-head" role="group" aria-label="statut du parrainage">
      <div class="badge chip-primary">
        <span class="chip-emoji" aria-hidden="true">🎁</span>
        <span class="chip-text">{{ ribbon|default:"Ton cadeau" }}</span>
      </div>
      <div class="badge badge-sec chip-secure">Lien sécurisé</div>
    </div>

    <div class="card-body">
      <div class="muted" style="margin-bottom:6px">{{ company_name }}</div>
      <h2 id="gift-title">{{ reward.label }}</h2>

      {% if reward.valid_until %}
        <div class="muted" style="margin:8px 0 16px">
          Date limite d’utilisation :
          {{ reward.valid_until|date:"d F Y" }}
        </div>
      {% endif %}

      <div class="panel">
        Présentez <strong>ce lien</strong> en caisse. Un membre de l’équipe validera la récompense.
        <div class="row">
          <div>
            <div class="muted" style="margin:10px 0 6px">Ton lien</div>
            <div class="codebox" id="copybox">
              <span class="url">{{ claim_absolute }}</span>
              <button class="btn" id="copyBtn" data-url="{{ claim_absolute }}">Copier le lien</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <div class="footer">
    Merci pour la recommandation ❤️ — {{ company_name|default:"" }}
  </div>

  <script>
    (function(){
      const btn = document.getElementById('copyBtn');
      if(!btn) return;
      btn.addEventListener('click', async function(){
        try{
          const url = btn.getAttribute('data-url') || location.href;
          await navigator.clipboard.writeText(url);
          btn.textContent = "Copié !";
          setTimeout(()=> btn.textContent = "Copier le lien", 1600);
        }catch(e){
          alert("Lien: " + (btn.getAttribute('data-url') || location.href));
        }
      });
    })();
  </script>
</body>
</html>
===== ./templates/rewards/test_wheel.html =====
{% extends "base_dashboard.html" %}
{% block title %}Roue de test • Chuchote{% endblock %}
{% block body_data_page %}recompenses{% endblock %}

{% block content %}
<style>
.wheel { --accent:#6c757d; width:300px; height:300px; border-radius:50%;
  border:8px solid var(--accent); position:relative; margin:0 auto;
  box-shadow:0 0 0 4px rgba(0,0,0,.03), 0 0 30px rgba(0,0,0,.06) inset;
  transition: box-shadow .3s ease, border-color .3s ease;
}
.wheel.is-spinning { box-shadow:0 0 0 4px rgba(0,0,0,.03), 0 0 46px var(--accent); }
.wheel::after{ content:""; position:absolute; top:-20px; left:50%; transform:translateX(-50%);
  width:0; height:0; border-left:12px solid transparent; border-right:12px solid transparent;
  border-bottom:22px solid var(--accent); filter: drop-shadow(0 2px 0 rgba(0,0,0,.15));
}
.wheel__disk{ position:absolute; inset:16px; border-radius:50%;
  background: conic-gradient(
    rgba(25,135,84,.90) 0deg,   rgba(25,135,84,.90) 90deg,
    rgba(13,202,240,.90) 90deg, rgba(13,202,240,.90) 180deg,
    rgba(253,126,20,.92) 180deg,rgba(253,126,20,.92) 270deg,
    rgba(220,53,69,.92) 270deg, rgba(220,53,69,.92) 360deg
  );
  transform-origin:50% 50%;
}
.spin-anim { transition: transform 2.2s cubic-bezier(.17,.67,.13,1.02); }
.wheel--success { --accent:#198754; }  /* SOUVENT */
.wheel--info    { --accent:#0dcaf0; }  /* MOYEN   */
.wheel--warning { --accent:#fd7e14; }  /* RARE    */
.wheel--danger  { --accent:#dc3545; }  /* TRES_RARE */
.wheel--secondary { --accent:#6c757d; } /* NO_HIT  */
.result-card { border-left:4px solid var(--accent); }
</style>

<header class="mb-4 d-flex justify-content-between align-items-center">
  <div>
    <h1 class="h5 mb-1">Roue de test (aléatoire, sans attribution)</h1>
    <div class="text-secondary">Tire au sort un bucket selon la distribution choisie.</div>
  </div>
  <a class="btn btn-outline-secondary" href="{% url 'rewards:list' %}">← Récompenses</a>
</header>

<form class="card mb-3" method="get">
  <div class="card-body row g-2 align-items-end">
    <div class="col-sm-4">
      <label class="form-label">Mode</label>
      <select name="mode" class="form-select">
        <option value="combined" {% if mode == 'combined' %}selected{% endif %}>Combiné (1/100000 très rare + base 980/19/1)</option>
        <option value="base" {% if mode == 'base' %}selected{% endif %}>Base (SOUVENT/MOYEN/RARE)</option>
        <option value="very_rare" {% if mode == 'very_rare' %}selected{% endif %}>Très rare uniquement</option>
      </select>
    </div>
    <div class="col-sm-3">
      <label class="form-label">Seed (optionnel)</label>
      <input type="text" class="form-control" name="seed" value="{{ seed }}">
    </div>
    <div class="col-sm-3">
      <label class="form-label">Simuler N tirages (optionnel)</label>
      <input type="number" class="form-control" name="n" value="{{ simulate_n|default:0 }}" min="0" step="1">
    </div>
    <div class="col-sm-2 d-flex gap-2">
      <button class="btn btn-primary w-100" type="submit">Tirer</button>
      <a class="btn btn-outline-secondary" href="{% url 'rewards:test_wheel' %}">Reset</a>
    </div>
  </div>
</form>

<div class="card shadow-sm mb-3">
  <div class="card-body d-flex flex-column align-items-center">
    <div class="wheel wheel--{{ ui.badge }} is-spinning">
      <div id="disk" class="wheel__disk spin-anim"></div>
    </div>
    <div class="mt-4 text-center result-card px-3 py-2 rounded">
      <span class="badge text-bg-{{ ui.badge }} me-2">
        {% if bucket == 'NO_HIT' %}Aucun gain{% else %}{{ ui.label }}{% endif %}
      </span>
      <strong id="rewardLabel">
        {% if bucket == 'SOUVENT' %}-10 %{% elif bucket == 'MOYEN' %}-20 %{% elif bucket == 'RARE' %}Cadeau rare{% elif bucket == 'TRES_RARE' %}Jackpot !{% else %}—{% endif %}
      </strong>
    </div>
  </div>
</div>

{% if counts %}
<div class="card">
  <div class="card-header">Simulation ({{ simulate_n }} tirages)</div>
  <div class="card-body">
    <div class="table-responsive">
      <table class="table table-sm align-middle">
        <thead>
          <tr><th>Bucket</th><th>Occurences</th><th>% observé</th></tr>
        </thead>
        <tbody>
          {% for k,v in counts.items %}
          <tr>
            <td>{{ k }}</td>
            <td>{{ v }}</td>
            <td>{{ pct|get_item:k|default:"0" }} %</td>
          </tr>
          {% endfor %}
        </tbody>
      </table>
    </div>
    <div class="text-secondary small">
      Combiné attendu (théorique) : TRES_RARE ≈ 0.001 %, sinon base 980/1000, 19/1000, 1/1000.
    </div>
  </div>
</div>
{% endif %}

<script>
(function(){
  const disk = document.getElementById('disk');
  const target = {{ target_angle|default:1440 }};
  setTimeout(()=>{ disk.style.transform = `rotate(${target}deg)`; }, 60);
  disk.addEventListener('transitionend', () => {
    const wheel = disk.closest('.wheel');
    wheel && wheel.classList.remove('is-spinning');
  }, { once: true });
})();
</script>
{% endblock %}
===== ./templates/rewards/list.html =====
{# templates/rewards/list.html #}
{% extends "base_dashboard.html" %}
{% block title %}Récompenses • ParrainApp{% endblock %}
{% block body_data_page %}recompenses{% endblock %}

{% block content %}
<header class="mb-4">
  <h1 class="h4 section-title mb-1">Récompenses</h1>
  <div class="text-secondary">Définissez les cadeaux (nom) et le délai. Les probabilités sont fixes.</div>
</header>

{% if not items %}
  <div class="card shadow-sm"><div class="card-body text-secondary">Aucune récompense.</div></div>
{% else %}
  <div class="row g-3">
    {% for r, ui in items %}
      <div class="col-md-6 col-xl-3">
        <div class="card h-100 shadow-sm">
          <div class="card-header bg-{{ ui.badge }}-subtle d-flex justify-content-between">
            <span class="badge text-bg-{{ ui.badge }}">
              {% if ui.label == "Moyen" %}Moyen{% else %}{{ ui.label }}{% endif %}
            </span>
            <small class="text-secondary">~{{ r.probability_display }}</small>
          </div>
          <div class="card-body d-flex flex-column">
            <h3 class="h6">{{ r.label }}</h3>

            <div class="text-secondary small">
              Délai : {{ r.cooldown_months }} mois
            </div>
            <div class="text-secondary small mb-3">
              Minimum requis : {{ r.min_referrals_required }} parrainage{{ r.min_referrals_required|pluralize }}
            </div>

            <div class="mt-auto d-flex gap-2">
              <a class="btn btn-sm btn-outline-primary" href="{% url 'rewards:update' r.pk %}">Modifier</a>
            </div>
          </div>
        </div>
      </div>
    {% endfor %}
  </div>
{% endif %}
{# Données probabilistes — mêmes constantes que Reward #}
{{ TEST_WHEEL|json_script:"wt-data" }}

<style>
#wheel-test .wheel{
  --accent:#6c757d;
  width:300px;height:300px;border-radius:50%;
  border:8px solid var(--accent);position:relative;margin:0 auto;
  box-shadow:0 0 0 4px rgba(0,0,0,.03), inset 0 0 30px rgba(0,0,0,.06);
  transition: box-shadow .3s ease, border-color .3s ease;
}
#wheel-test .wheel.is-spinning{ box-shadow:0 0 0 4px rgba(0,0,0,.03), 0 0 46px var(--accent); }

#wheel-test .needle{
  position:absolute; top:-20px; left:50%; transform:translateX(-50%);
  width:0;height:0;border-left:12px solid transparent;border-right:12px solid transparent;
  border-bottom:22px solid var(--accent); filter: drop-shadow(0 2px 0 rgba(0,0,0,.15));
}

/* 4 segments visuels (égaux) pour une belle animation ; le tirage, lui, respecte les vraies probas */
#wheel-test .wheel__disk{
  position:absolute; inset:16px; border-radius:50%;
  background: conic-gradient(
    rgba(25,135,84,.90) 0deg,   rgba(25,135,84,.90) 90deg,   /* SOUVENT  */
    rgba(13,202,240,.90) 90deg, rgba(13,202,240,.90) 180deg, /* MOYEN    */
    rgba(253,126,20,.92) 180deg,rgba(253,126,20,.92) 270deg, /* RARE     */
    rgba(220,53,69,.92) 270deg, rgba(220,53,69,.92) 360deg   /* TRES_RARE */
  );
  transform-origin:50% 50%;
}
#wheel-test .spin-anim{ transition: transform 2.2s cubic-bezier(.17,.67,.13,1.02); }

#wheel-test .wheel--success { --accent:#198754; }
#wheel-test .wheel--info    { --accent:#0dcaf0; }
#wheel-test .wheel--warning { --accent:#fd7e14; }
#wheel-test .wheel--danger  { --accent:#dc3545; }
#wheel-test .wheel--secondary{ --accent:#6c757d; }

#wheel-test .result-card{ border-left:4px solid var(--accent); }
</style>

<section id="wheel-test" class="mt-4">
  <div class="card mb-3">
    <div class="card-header d-flex justify-content-between align-items-center">
      <span>🎡 Roue de test (aléatoire, sans attribution)</span>
      <span class="text-secondary small">Utilise les mêmes probas que Reward (1/100000 très rare + 980/19/1)</span>
    </div>
    <div class="card-body">
      <form class="row g-2 align-items-end" onsubmit="return false;">
        <div class="col-md-3">
          <label class="form-label">Simuler N tirages (optionnel)</label>
          <input id="wt-n" type="number" class="form-control" min="0" step="1" value="0">
        </div>
        <div class="col-md-3">
          <label class="form-label">Seed (optionnel)</label>
          <input id="wt-seed" type="text" class="form-control" placeholder="ex: 42">
        </div>
        <div class="col-md-6 d-flex gap-2">
          <button id="wt-draw" class="btn btn-primary" type="button">Tirer</button>
          <button id="wt-reset" class="btn btn-outline-secondary" type="button">Reset</button>
        </div>
      </form>

      <div class="mt-4 d-flex flex-column align-items-center">
        <div id="wt-wheel" class="wheel wheel--secondary">
          <div class="needle" aria-hidden="true"></div>
          <div id="wt-disk" class="wheel__disk spin-anim"></div>
        </div>

        <div id="wt-result" class="mt-4 text-center result-card px-3 py-2 rounded">
          <span id="wt-badge" class="badge text-bg-secondary me-2">—</span>
          <strong id="wt-label">—</strong>
        </div>
      </div>

      <div id="wt-sim" class="table-responsive mt-4 d-none">
        <table class="table table-sm align-middle mb-0">
          <thead><tr><th>Bucket</th><th>Occurences</th><th>% observé</th></tr></thead>
          <tbody id="wt-rows"></tbody>
        </table>
      </div>
    </div>
  </div>
</section>

<script>
(function(){
  // --- Ordre d’affichage & UI (inchangé) ---
  const ORDER = ["SOUVENT","MOYEN","RARE","TRES_RARE"];
  const UI = {
    SOUVENT:   { badge: "success",  label: "Souvent",   text: "-10 %" },
    MOYEN:     { badge: "info",     label: "Moyen",     text: "-20 %" },
    RARE:      { badge: "warning",  label: "Rare",      text: "Cadeau rare" },
    TRES_RARE: { badge: "danger",   label: "Très rare", text: "Jackpot !" },
  };

  // ---- RNG seedable (xorshift32) — on garde tel quel ----
  function hashSeed(s){ let h=2166136261>>>0; for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,16777619);} return h>>>0; }
  function rngFromSeed(seedStr){
    if (!seedStr) return Math.random;
    let x = (typeof seedStr==="number"?seedStr:hashSeed(String(seedStr))) || 1;
    return function(){ x^=x<<13; x^=x>>>17; x^=x<<5; x>>>=0; return x/4294967296; };
  }

  // ---- Probabilités demandées (brutes) ----
  // SOUVENT=80/100, MOYEN=19/100, RARE=0.99999/100, TRES_RARE=1/100000
  const RAW = {
    SOUVENT:   80/100,
    MOYEN:     19/100,
    RARE:      0.99999/100,
    TRES_RARE: 1/100000
  };

  // Normalisation pour que la somme = 1 exactement
  const MASS = Object.values(RAW).reduce((a,b)=>a+b,0);
  const W = Object.fromEntries(ORDER.map(k => [k, RAW[k] / MASS]));

  // ---- Tirage cumulatif sur les poids normalisés (une seule passe) ----
  function drawOnce(rnd){
    const x = rnd();
    let acc = 0;
    for (const k of ORDER){
      acc += W[k];
      if (x < acc) return k;
    }
    return ORDER[ORDER.length-1]; // sauvegarde (jamais atteinte en pratique)
  }

  // ---- UI helpers (inchangés) ----
  const $ = (id)=>document.getElementById(id);
  const disk  = $("wt-disk");
  const wheel = $("wt-wheel");
  const badge = $("wt-badge");
  const label = $("wt-label");
  const rows  = $("wt-rows");
  const simBox= $("wt-sim");

  function animateTo(bucket){
    const ui = UI[bucket];
    wheel.className = "wheel wheel--" + ui.badge + " is-spinning";
    badge.className = "badge text-bg-" + ui.badge + " me-2";
    badge.textContent = ui.label;
    label.textContent = ui.text;

    const segment = 360 / ORDER.length;
    const idx = Math.max(0, ORDER.indexOf(bucket));
    const target = 4*360 + Math.floor(idx * segment + segment/2);
    requestAnimationFrame(()=>{ disk.style.transform = `rotate(${target}deg)`; });
    disk.addEventListener("transitionend", ()=> wheel.classList.remove("is-spinning"), {once:true});
  }

  function simulate(n, rnd){
    const buckets = ORDER.slice();
    const counts = Object.fromEntries(buckets.map(b=>[b,0]));
    for (let i=0;i<n;i++) counts[drawOnce(rnd)]++;
    const tot = buckets.reduce((a,b)=>a+counts[b],0)||1;
    rows.innerHTML = "";
    buckets.forEach(k=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${k}</td><td>${counts[k]}</td><td>${(counts[k]*100/tot).toFixed(2)} %</td>`;
      rows.appendChild(tr);
    });
    simBox.classList.toggle("d-none", n<=0);
  }

  // ---- Évènements (inchangés) ----
  $("wt-draw").addEventListener("click", ()=>{
    const N   = parseInt($("wt-n").value||"0",10);
    const seed= $("wt-seed").value;
    const rnd = rngFromSeed(seed);
    const b = drawOnce(rnd);
    animateTo(b);
    if (N>0) simulate(N, rngFromSeed(seed));
  });

  $("wt-reset").addEventListener("click", ()=>{
    $("wt-n").value = 0; $("wt-seed").value = "";
    simBox.classList.add("d-none"); rows.innerHTML = "";
    wheel.className = "wheel wheel--secondary";
    badge.className = "badge text-bg-secondary me-2";
    badge.textContent = "—"; label.textContent = "—";
    disk.style.transform = "rotate(0deg)";
  });
})();
</script>


{% endblock %}
===== ./templates/rewards/history.html =====
{# templates/rewards/history.html #}
{% extends "base_dashboard.html" %}
{% load dict_extras %}

{% block title %}Historique des récompenses • {{ company.name }}{% endblock %}
{% block body_data_page %}recompenses{% endblock %}

{% block content %}
<header class="mb-4">
  <h1 class="h4 section-title mb-2">Historique des récompenses — {{ company.name }}</h1>
  <div class="text-secondary">Toutes les récompenses de l’entreprise, tous clients confondus.</div>
</header>

<div class="card shadow-sm mb-3">
  <div class="card-body">
    <form method="get" class="row g-2 align-items-end">
      {# ✅ très important pour le Superadmin : conserver l’entreprise ciblée #}
      {% if company and company.id %}
        <input type="hidden" name="company" value="{{ company.id }}">
      {% endif %}

      <div class="col-lg-4">
        <label class="form-label mb-1">Recherche</label>
        <input type="text" name="q" value="{{ q }}" class="form-control"
               placeholder="Client (nom/prénom/email) ou libellé de récompense…">
      </div>

      <div class="col-lg-3">
        <label class="form-label mb-1">État</label>
        <select name="state" class="form-select">
          <option value="">— Tous —</option>
          {% for k, lbl in states %}
            <option value="{{ k }}" {% if k == state %}selected{% endif %}>{{ lbl }}</option>
          {% endfor %}
        </select>
      </div>

      <div class="col-lg-3">
        <label class="form-label mb-1">Type</label>
        <select name="bucket" class="form-select">
          <option value="">— Tous —</option>
          {% for k, lbl in buckets %}
            <option value="{{ k }}" {% if k == bucket %}selected{% endif %}>{{ lbl }}</option>
          {% endfor %}
        </select>
      </div>

      <div class="col-lg-2 d-flex gap-2">
        <button class="btn btn-primary w-100" type="submit">Filtrer</button>
        {# ✅ réinitialiser tout en gardant le contexte company pour superadmin #}
        <a class="btn btn-outline-secondary"
           href="{% url 'rewards:history_company' %}{% if company and company.id %}?company={{ company.id }}{% endif %}">
          Réinitialiser
        </a>
      </div>
    </form>
  </div>
</div>

{% if page and page.object_list %}
  <div class="card shadow-sm">
    <div class="table-responsive">
      <table class="table align-middle mb-0">
        <thead class="table-light">
          <tr>
            <th style="width: 140px;">Date</th>
            <th>Client</th>
            <th style="width: 110px;">Rôle</th>
            <th>Récompense</th>
            <th style="width: 130px;">Type</th>
            <th style="width: 130px;">État</th>
          </tr>
        </thead>
        <tbody>
          {% for r in page.object_list %}
            <tr>
              <td>
                <div class="small">{{ r.created_at|date:"d/m/Y" }}</div>
                <div class="text-secondary small">{{ r.created_at|date:"H:i" }}</div>
              </td>

              <td>
                <div class="fw-semibold">
                  <a href="{% url 'dashboard:client_detail' pk=r.client_id %}" class="text-decoration-none">
                    {{ r.client.last_name }} {{ r.client.first_name }}
                  </a>
                </div>
                <div class="text-secondary small">{{ r.client.email|default:"—" }}</div>
              </td>

              <td>
                {% if r.referral_id %}
                  {% if r.client_id == r.referral.referrer_id %}
                    <span class="badge text-bg-info">Parrain</span>
                  {% elif r.client_id == r.referral.referee_id %}
                    <span class="badge text-bg-secondary">Filleul</span>
                  {% else %}
                    <span class="badge text-bg-light text-dark">Autre</span>
                  {% endif %}
                {% else %}
                  <span class="text-secondary small">—</span>
                {% endif %}
              </td>

              <td><div class="fw-semibold">{{ r.label }}</div></td>

              <td>
                {# ✅ lire BUCKET_UI[r.bucket] en utilisant le filtre get_item #}
                {% with ui=BUCKET_UI|get_item:r.bucket %}
                  <span class="badge text-bg-{{ ui.badge|default:'secondary' }}">{{ ui.label|default:r.bucket }}</span>
                {% endwith %}
              </td>

              <td>
                {# ✅ lire STATE_UI[r.state] en utilisant le filtre get_item #}
                {% with st=STATE_UI|get_item:r.state %}
                  <span class="badge text-bg-{{ st.badge|default:'secondary' }}">{{ st.label|default:r.state }}</span>
                {% endwith %}
              </td>
            </tr>
          {% endfor %}
        </tbody>
      </table>
    </div>

    {% if page.paginator.num_pages > 1 %}
      <div class="card-footer bg-transparent d-flex justify-content-end align-items-center gap-2">
        {% if page.has_previous %}
          <a class="btn btn-sm btn-outline-secondary"
             href="?p={{ page.previous_page_number }}&bucket={{ bucket }}&state={{ state }}&q={{ q|urlencode }}{% if company and company.id %}&company={{ company.id }}{% endif %}">
            Préc.
          </a>
        {% endif %}
        <span class="small">Page {{ page.number }}/{{ page.paginator.num_pages }}</span>
        {% if page.has_next %}
          <a class="btn btn-sm btn-outline-secondary"
             href="?p={{ page.next_page_number }}&bucket={{ bucket }}&state={{ state }}&q={{ q|urlencode }}{% if company and company.id %}&company={{ company.id }}{% endif %}">
            Suiv.
          </a>
        {% endif %}
      </div>
    {% endif %}
  </div>
{% else %}
  <div class="card shadow-sm">
    <div class="card-body text-secondary">Aucune récompense trouvée pour ces critères.</div>
  </div>
{% endif %}
{% endblock %}
===== ./templates/rewards/confirm_delete.html =====
{# templates/rewards/confirm_delete.html #}
{% extends "base_dashboard.html" %}
{% block title %}Supprimer la récompense{% endblock %}

{% block content %}
<header class="mb-3">
  <h1 class="h4 section-title mb-1">Supprimer la récompense</h1>
</header>

<div class="card shadow-sm">
  <div class="card-body">
    <p>Supprimer définitivement <strong>{{ reward.label }}</strong> ?</p>
    <form method="post" class="d-flex gap-2">
      {% csrf_token %}
      <button class="btn btn-danger" type="submit">Supprimer</button>
      <a class="btn btn-outline-secondary" href="{% url 'rewards:list' %}">Annuler</a>
    </form>
  </div>
</div>
{% endblock %}
===== ./templates/rewards/use_reward_done.html =====
{% extends "base_dashboard.html" %}
{% block title %}Récompense utilisée{% endblock %}

{% block content %}
<div class="card shadow-sm">
  <div class="card-body text-center">
    <h2 class="h4 mb-3">🎉 Bravo !</h2>
    <p>Vous venez d’utiliser la récompense :</p>
    <h3 class="h5">{{ reward.label }}</h3>
    <p class="text-secondary">Statut : <span class="badge bg-success">Utilisée</span></p>
  </div>
</div>
{% endblock %}

===== ./rewards/templatetags/ __init__.py =====
===== ./rewards/templatetags/url_extras.py =====
from django import template

register = template.Library()

@register.simple_tag(takes_context=True)
def abs_uri(context, path: str) -> str:
    """
    Construit une URL absolue à partir d'un path relatif, en utilisant request si dispo.
    Usage dans template:
      {% abs_uri rw.claim_path as claim_abs %}
    """
    request = context.get("request")
    if not path:
        return ""
    return request.build_absolute_uri(path) if request else path
===== ./rewards/signals.py =====
# rewards/signals.py
from django.db.models.signals import pre_save
from django.dispatch import receiver
from .models import Reward

@receiver(pre_save, sender=Reward)
def reward_token_autogen(sender, instance: Reward, **kwargs):
    if not instance.token:
        instance.ensure_token()
===== ./rewards/views_wheels.py =====
===== ./rewards/models.py =====
# rewards/models.py
from datetime import timedelta
import secrets

from django.db import models
from django.utils import timezone
from django.urls import reverse

from accounts.models import Company
from dashboard.models import Client, Referral


class ProbabilityWheel(models.Model):
    """
    Roue (pool) cyclique par entreprise.
    - key   : identifie un tirage (ex: 'base_100', 'very_rare_10000')
    - pool  : liste ordonnée des résultats (ex: ['SOUVENT','SOUVENT',...,'NO_HIT'])
    - idx   : curseur de consommation
    - size  : longueur totale du pool (copie pour debug)
    """
    company = models.ForeignKey(
        Company, on_delete=models.CASCADE, related_name="probability_wheels"
    )
    key = models.SlugField(max_length=64)
    pool = models.JSONField(default=list)
    idx = models.PositiveIntegerField(default=0)
    size = models.PositiveIntegerField(default=0)

    class Meta:
        unique_together = (("company", "key"),)
        indexes = [models.Index(fields=["company", "key"])]

    def __str__(self):
        return f"{self.company} • {self.key} ({self.idx}/{self.size})"


class RewardTemplate(models.Model):
    BUCKETS = (
        ("SOUVENT", "Souvent"),
        ("MOYEN", "Moyen"),
        ("RARE", "Rare"),
        ("TRES_RARE", "Très rare"),
    )

    company = models.ForeignKey(
        Company, on_delete=models.CASCADE, related_name="reward_templates"
    )
    bucket = models.CharField(max_length=10, choices=BUCKETS)

    label = models.CharField(max_length=120, default="-10 % de remise")
    cooldown_months = models.PositiveSmallIntegerField(default=1)
    cooldown_days = models.PositiveIntegerField(default=30)

    # Seuil d’éligibilité
    min_referrals_required = models.PositiveIntegerField(
        default=0,
        help_text="Nombre minimum de parrainages requis pour débloquer cette récompense."
    )

    # Purement affichage (ex. '980/1000')
    probability_display = models.CharField(max_length=20, default="", editable=False)

    class Meta:
        unique_together = (("company", "bucket"),)
        ordering = ("company", "bucket")

    def save(self, *args, **kwargs):
        self.cooldown_days = int(self.cooldown_months) * 30
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.company} • {self.get_bucket_display()} • {self.label}"


class Reward(models.Model):
    BUCKETS = (
        ("SOUVENT", "Souvent"),
        ("MOYEN", "Moyen"),
        ("RARE", "Rare"),
        ("TRES_RARE", "Très rare"),
    )
    STATE_CHOICES = (
        ("PENDING", "En attente"),
        ("SENT", "Envoyée"),
        ("DISABLED", "Désactivée"),
        ("ARCHIVED", "Archivée"),
    )

    company = models.ForeignKey(Company, on_delete=models.CASCADE, related_name="rewards")
    client = models.ForeignKey(Client, on_delete=models.CASCADE, related_name="rewards")

    referral = models.ForeignKey(
        Referral, on_delete=models.CASCADE, related_name="rewards",
        null=True, blank=True
    )

    label = models.CharField(max_length=255)
    bucket = models.CharField(max_length=20, choices=BUCKETS)
    cooldown_days = models.PositiveIntegerField(default=0)
    state = models.CharField(max_length=20, choices=STATE_CHOICES, default="PENDING")
    created_at = models.DateTimeField(auto_now_add=True)

    token = models.CharField(max_length=64, unique=True, db_index=True, null=True, blank=True)
    token_expires_at = models.DateTimeField(null=True, blank=True)

    redeemed_at = models.DateTimeField(null=True, blank=True)
    redeemed_channel = models.CharField(max_length=20, blank=True)

    class Meta:
        indexes = [models.Index(fields=["company", "client", "state"])]
        constraints = [
            models.UniqueConstraint(
                fields=["company", "client", "referral"],
                name="uniq_reward_by_referrer_and_referral",
            )
        ]

    # ----------------- Helpers d’affichage -----------------

    def ensure_token(self, force: bool = False):
        if force or not self.token:
            self.token = secrets.token_urlsafe(24)
        if not self.token_expires_at:
            days = int(self.cooldown_days or 180)
            self.token_expires_at = timezone.now() + timedelta(days=days)

    @property
    def valid_until(self):
        if self.cooldown_days and self.created_at:
            return self.created_at + timedelta(days=int(self.cooldown_days))
        return None

    @property
    def cooldown_label(self) -> str:
        d = int(self.cooldown_days or 0)
        if d == 0:
            return "illimité"
        if d % 30 == 0:
            m = d // 30
            return f"{m} mois" if m > 1 else "1 mois"
        return f"{d} jours"

    def validity_sentence(self) -> str:
        if self.valid_until:
            return f"Validité : {self.cooldown_label} (jusqu’au {timezone.localtime(self.valid_until).strftime('%d/%m/%Y')})"
        return "Validité : illimité"

    @property
    def claim_path(self) -> str:
        return reverse("rewards:use_reward", kwargs={"token": self.token}) if self.token else ""

    @property
    def claim_url(self) -> str:
        return self.claim_path

    def __str__(self):
        return f"{self.label} ({self.get_bucket_display()})"
===== ./rewards/probabilities.py =====
from __future__ import annotations
from dataclasses import dataclass
from typing import Iterable, List, Tuple
from django.db import transaction
from django.utils.text import slugify
from rewards.models import ProbabilityWheel
from accounts.models import Company

# --------- Utilitaires de pool ----------
def build_pool(pairs: Iterable[Tuple[int, str]]) -> List[str]:
    pool: List[str] = []
    for n, val in pairs:
        if n < 0:
            raise ValueError("n négatif")
        pool.extend([val] * n)
    return pool

def interleave(pool: List[str]) -> List[str]:
    from collections import defaultdict, deque
    buckets = defaultdict(deque)
    for v in pool:
        buckets[v].append(v)

    keys = sorted(buckets.keys(), key=lambda k: -len(buckets[k]))
    out: List[str] = []
    while any(buckets[k] for k in keys):
        for k in keys:
            if buckets[k]:
                out.append(buckets[k].popleft())
    return out

# --------- API principale ----------
@dataclass
class WheelSpec:
    key: str
    pairs: Tuple[Tuple[int, str], ...]

def ensure_wheel(company: Company, spec: WheelSpec) -> ProbabilityWheel:
    key = slugify(spec.key)
    raw = build_pool(spec.pairs)
    pool = interleave(raw) if len(set(raw)) > 1 else raw
    with transaction.atomic():
        obj, _created = ProbabilityWheel.objects.select_for_update().get_or_create(
            company=company, key=key, defaults={"pool": pool, "size": len(pool), "idx": 0}
        )
        if obj.size != len(pool) or obj.pool != pool:
            obj.pool = pool
            obj.size = len(pool)
            obj.idx = obj.idx % (len(pool) or 1)
            obj.save(update_fields=["pool", "size", "idx"])
    return obj

def draw(company: Company, key: str) -> str:
    k = slugify(key)
    with transaction.atomic():
        wheel = ProbabilityWheel.objects.select_for_update().get(company=company, key=k)
        if wheel.size == 0:
            raise ValueError("Roue vide")
        value = wheel.pool[wheel.idx]
        wheel.idx = (wheel.idx + 1) % wheel.size
        wheel.save(update_fields=["idx"])
        return value

# --------- Specs prêtes à l’emploi ----------
BASE_100 = WheelSpec(
    key="base_100",
    pairs=((80, "Souvent"), (19, "Moyen"), (1, "Rare")),
)
VERY_RARE_10000 = WheelSpec(
    key="very_rare_10000",
    pairs=((9999, "NO_HIT"), (1, "Très rare")),
)
===== ./rewards/tests/test_real_draws.py =====
# rewards/tests/test_real_draws.py
import pytest
from collections import Counter
from django.utils import timezone

from accounts.models import Company
from dashboard.models import Client, Referral
from rewards.models import RewardTemplate
from rewards.services.probabilities import (
    ensure_wheels, tirer_recompense,
    SOUVENT, MOYEN, RARE, TRES_RARE,
)

pytestmark = pytest.mark.django_db


# ----------------------------
# Helpers
# ----------------------------

def _mk_company_with_templates(
    name="Acme",
    min_rare=0,
    min_tres_rare=0,
    label_map=None,
):
    """
    Crée une entreprise + les 4 RewardTemplate avec les minimums d’éligibilité voulus.
    Les probas affichées ne servent que d'info; la vraie distribution vient des roues.
    """
    c = Company.objects.create(name=name, slug=name.lower())
    defaults = {
        SOUVENT:   {"label": "-10 %", "cooldown_months": 1, "min": 0,           "prob": "980/1000"},
        MOYEN:     {"label": "-20 %", "cooldown_months": 1, "min": 0,           "prob": "19/1000"},
        RARE:      {"label": "Rare",  "cooldown_months": 3, "min": min_rare,    "prob": "1/1000"},
        TRES_RARE: {"label": "Jackpot","cooldown_months": 6,"min": min_tres_rare,"prob": "1/100000"},
    }
    label_map = label_map or {}
    for bucket, meta in defaults.items():
        RewardTemplate.objects.create(
            company=c,
            bucket=bucket,
            label=label_map.get(bucket, meta["label"]),
            cooldown_months=meta["cooldown_months"],
            min_referrals_required=meta["min"],
            probability_display=meta["prob"],
        )
    ensure_wheels(c)  # pool base (1000) et very_rare (100000) à idx=0
    return c


def _client(company, first="A", last="B"):
    return Client.objects.create(company=company, first_name=first, last_name=last)


def _seed_referrals(company, referrer, n):
    """Crée n parrainages où `referrer` est le parrain (le filleul importe peu ici)."""
    for i in range(n):
        referee = Client.objects.create(company=company, first_name=f"F{i}", last_name="X")
        Referral.objects.create(
            company=company, referrer=referrer, referee=referee, created_at=timezone.now()
        )


def _draw_n(company, client, n):
    cnt = Counter()
    for _ in range(n):
        cnt[tirer_recompense(company, client)] += 1
    # S’assure que toutes les clés existent
    for k in (SOUVENT, MOYEN, RARE, TRES_RARE):
        cnt.setdefault(k, 0)
    return cnt


# ----------------------------
# Tests “partie réelle” (consommation des roues)
# ----------------------------

def test_first_100_draws_from_fresh_cycle_are_all_souvent():
    """
    Avec des roues neuves (idx=0) et client éligible à tout,
    les 100 premiers tirages tombent forcément sur SOUVENT (pool base ordonné).
    """
    c = _mk_company_with_templates(name="AllEligible")
    client = _client(c)
    cnt = _draw_n(c, client, 100)
    assert cnt[SOUVENT] == 100
    assert cnt[MOYEN] == cnt[RARE] == cnt[TRES_RARE] == 0


def test_full_base_cycle_1000_all_eligible_gives_980_19_1():
    """
    Sur un cycle complet de la roue base (1000 tirages) avec tout éligible :
    980 SOUVENT, 19 MOYEN, 1 RARE. TRES_RARE n’apparaît pas avant 100000 tirages.
    """
    c = _mk_company_with_templates(name="Cycle1000")  # tout éligible
    client = _client(c)
    cnt = _draw_n(c, client, 1000)
    assert cnt[SOUVENT] == 980
    assert cnt[MOYEN] == 19
    assert cnt[RARE] == 1
    assert cnt[TRES_RARE] == 0


def test_very_rare_exactly_once_per_100000_when_eligible():
    """
    Quand TRES_RARE est éligible, il sort exactement 1 fois par cycle de 100000 tirages.
    Les 99999 autres tirages consomment la roue base (99 cycles complets + 999 entrées).
    """
    c = _mk_company_with_templates(name="VeryRareEligible")
    client = _client(c)

    cnt = _draw_n(c, client, 100_000)

    # 1 seul TRES_RARE
    assert cnt[TRES_RARE] == 1

    # Répartition base attendue sur 99 cycles + 999 tirages (indices 0..998)
    # 99 cycles -> 99*980, 99*19, 99*1
    # +999 tirages -> 980 SOUVENT + 19 MOYEN
    assert cnt[SOUVENT] == 98_000   # 97_020 + 980
    assert cnt[MOYEN]   == 1_900    # 1_881 + 19
    assert cnt[RARE]    == 99       # 99
    # Somme de contrôle
    assert sum(cnt.values()) == 100_000


def test_ineligible_rare_and_very_rare_gives_981_souvent_19_moyen_on_1000():
    """
    Seuils RARE=10, TRES_RARE=12 ; client avec 9 parrainages => RARE/TRES_RARE inéligibles.
    Sur 1000 tirages, la case RARE (dernière du pool base) est “sautée” et remplacée par
    la case suivante autorisée => 981 SOUVENT, 19 MOYEN, 0 RARE, 0 TRES_RARE.
    """
    c = _mk_company_with_templates(name="MinThresholds", min_rare=10, min_tres_rare=12)
    client = _client(c)
    _seed_referrals(c, client, 9)  # inéligible à RARE/TRES_RARE

    cnt = _draw_n(c, client, 1000)
    assert cnt[SOUVENT] == 981
    assert cnt[MOYEN] == 19
    assert cnt[RARE] == 0
    assert cnt[TRES_RARE] == 0


def test_rare_becomes_eligible_at_10_but_tres_rare_not_yet():
    """
    À 10 parrainages : RARE devient éligible, pas TRES_RARE.
    On retrouve donc 980/19/1 sur 1000 tirages.
    """
    c = _mk_company_with_templates(name="RareOnly", min_rare=10, min_tres_rare=12)
    client = _client(c)
    _seed_referrals(c, client, 10)

    cnt = _draw_n(c, client, 1000)
    assert cnt[SOUVENT] == 980
    assert cnt[MOYEN] == 19
    assert cnt[RARE] == 1
    assert cnt[TRES_RARE] == 0


def test_tres_rare_apparait_juste_apres_99999_tirs_quand_il_devient_eligible():
    """
    Démonstration du “skip” propre :
    - On tire 99 999 fois alors que TRES_RARE est inéligible -> on consomme tout le NO_HIT.
    - On rend ensuite TRES_RARE éligible -> le tirage suivant tombe sur la case TRES_RARE.
    """
    # Au départ TR inéligible
    c = _mk_company_with_templates(name="EnableLater", min_rare=0, min_tres_rare=1)
    client = _client(c)

    # 0 parrainage -> TR inéligible
    cnt1 = _draw_n(c, client, 99_999)
    assert cnt1[TRES_RARE] == 0

    # Devient éligible (1 parrainage)
    _seed_referrals(c, client, 1)
    cnt2 = _draw_n(c, client, 1)
    assert cnt2[TRES_RARE] == 1
===== ./rewards/tests/__init__.py =====
===== ./rewards/tests/test_sms_send.py =====
import pytest
from django.urls import reverse

@pytest.mark.django_db
def test_reward_send_sms_requires_login(client):
    url = reverse("rewards:reward_send_sms", kwargs={"pk": 1})
    resp = client.post(url)
    assert resp.status_code in (302, 301)  # redirection vers login
===== ./rewards/management/ __init__.py =====
===== ./rewards/management/commands/init_probability_wheels.py =====
from django.core.management.base import BaseCommand, CommandError
from accounts.models import Company
from rewards.services.probabilities import ensure_wheels

class Command(BaseCommand):
    help = "Initialise les roues de probabilité pour une entreprise."

    def add_arguments(self, parser):
        parser.add_argument("--company", required=True, help="Slug de l'entreprise")

    def handle(self, *args, **options):
        slug = options["company"]
        try:
            company = Company.objects.get(slug=slug)
        except Company.DoesNotExist:
            raise CommandError(f"Company '{slug}' introuvable")

        ensure_wheels(company)
        self.stdout.write(self.style.SUCCESS(f"OK: {company} • base & very_rare"))
===== ./rewards/management/commands/seed_wheels.py =====
from django.core.management.base import BaseCommand
from accounts.models import Company
from rewards.services.probabilities import ensure_wheels_for_company

class Command(BaseCommand):
    help = "Initialise (ou ré-initialise) les roues de probabilités pour chaque entreprise."

    def add_arguments(self, parser):
        parser.add_argument(
            "--reset",
            action="store_true",
            help="Ré-initialise les roues (réécrit le pool et remet idx=0)."
        )

    def handle(self, *args, **options):
        reset = options["reset"]
        count = 0
        for company in Company.objects.all():
            ensure_wheels_for_company(company)
            count += 1
        self.stdout.write(self.style.SUCCESS(
            f"Roues initialisées pour {count} entreprise(s)."
        ))
        if reset:
            # Optionnel : si tu veux forcer un reset plus fort, tu peux
            # étendre ensure_wheels_for_company pour régénérer les pools
            self.stdout.write(self.style.WARNING(
                "Option --reset indiquée : assure-toi que ensure_wheels_for_company "
                "régénère les pools comme attendu."
            ))
===== ./rewards/management/commands/ __init__.py =====
===== ./rewards/management/commands/rebuild_wheels.py =====
from django.core.management.base import BaseCommand
from accounts.models import Company
from rewards.services.probabilities import ensure_wheels

class Command(BaseCommand):
    help = "Reconstruit/initialise les roues de probabilité pour chaque entreprise."

    def handle(self, *args, **opts):
        for c in Company.objects.filter(is_active=True):
            ensure_wheels(c)
            self.stdout.write(self.style.SUCCESS(f"{c.name}: wheels ensured"))
===== ./rewards/__init__.py =====
===== ./rewards/apps.py =====
# rewards/apps.py
from django.apps import AppConfig

class RewardsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "rewards"
    verbose_name = "Récompenses"

    def ready(self):
        import rewards.signals  # noqa
===== ./rewards/forms.py =====
# rewards/forms.py
from django import forms
from .models import RewardTemplate

class RewardTemplateForm(forms.ModelForm):
    # Limite à 17 caractères (serveur) + maxlength côté HTML
    label = forms.CharField(
        max_length=17,
        label="Nom de la récompense",
        widget=forms.TextInput(attrs={
            "class": "form-control",
            "placeholder": "Ex. -10 %",
            "maxlength": "17",   # limite côté navigateur
        }),
        error_messages={
            "max_length": "Maximum 17 caractères.",
        },
    )

    cooldown_months = forms.TypedChoiceField(
        choices=[(i, f"{i} mois") for i in range(1, 7)],
        coerce=int,
        label="Délai",
        widget=forms.Select(attrs={"class": "form-select"})
    )

    min_referrals_required = forms.IntegerField(
        min_value=0,
        label="Minimum de parrainages requis",
        widget=forms.NumberInput(attrs={
            "class": "form-control",
            "placeholder": "0",
            "inputmode": "numeric"
        })
    )

    class Meta:
        model = RewardTemplate
        fields = ("label", "cooldown_months", "min_referrals_required")

    def clean_label(self):
        """Validation supplémentaire (au cas où, après trim)."""
        value = (self.cleaned_data.get("label") or "").strip()
        if len(value) > 17:
            raise forms.ValidationError("Maximum 17 caractères.")
        return value
===== ./rewards/admin.py =====
# rewards/admin.py
from django.contrib import admin, messages
from django.db import IntegrityError, transaction
from django.utils.translation import gettext_lazy as _

from .models import ProbabilityWheel, RewardTemplate, Reward


@admin.action(description="Marquer sélection comme Envoyée")
def mark_sent(modeladmin, request, queryset):
    updated = queryset.update(state="SENT")
    messages.success(request, _(f"{updated} récompense(s) marquée(s) comme envoyée(s)."))

@admin.action(description="Marquer sélection comme En attente")
def mark_pending(modeladmin, request, queryset):
    updated = queryset.update(state="PENDING")
    messages.success(request, _(f"{updated} récompense(s) marquée(s) comme en attente."))

@admin.action(description="Marquer sélection comme Désactivée")
def mark_disabled(modeladmin, request, queryset):
    updated = queryset.update(state="DISABLED")
    messages.success(request, _(f"{updated} récompense(s) désactivée(s)."))

@admin.action(description="Archiver la sélection")
def mark_archived(modeladmin, request, queryset):
    updated = queryset.update(state="ARCHIVED")
    messages.success(request, _(f"{updated} récompense(s) archivée(s)."))

@admin.register(Reward)
class RewardAdmin(admin.ModelAdmin):
    list_display = (
        "company", "client", "referral",
        "label", "bucket", "state", "created_at",
    )
    list_filter = (
        "company", "bucket", "state", ("created_at", admin.DateFieldListFilter),
    )
    search_fields = (
        "label",
        "client__last_name", "client__first_name",
        "client__email", "client__phone",
    )
    list_select_related = ("company", "client", "referral")
    autocomplete_fields = ("client", "referral")
    date_hierarchy = "created_at"
    ordering = ("-created_at", "-id")
    actions = [mark_sent, mark_pending, mark_disabled, mark_archived]

    def save_model(self, request, obj, form, change):
        try:
            with transaction.atomic():
                super().save_model(request, obj, form, change)
        except IntegrityError:
            self.message_user(
                request,
                _("Une récompense existe déjà pour ce parrainage et ce parrain (règle: 1 par filleul)."),
                level=messages.ERROR,
            )

@admin.register(RewardTemplate)
class RewardTemplateAdmin(admin.ModelAdmin):
    list_display = (
        "company", "bucket", "label",
        "cooldown_months", "cooldown_days", "probability_display",
    )
    list_filter = ("company", "bucket")
    search_fields = ("label", "company__name")
    ordering = ("company", "bucket")
    readonly_fields = ("cooldown_days", "probability_display")

@admin.action(description="(Re)créer les deux roues pour l’entreprise (ensure_wheels)")
def action_ensure_wheels(modeladmin, request, queryset):
    companies = {w.company for w in queryset}
    for c in companies:
        ensure_wheels(c)
    messages.success(request, _(f"Roues vérifiées/régénérées pour {len(companies)} entreprise(s)."))

@admin.action(description="Régénérer la roue sélectionnée (repart à idx=0)")
def action_rebuild_selected(modeladmin, request, queryset):
    for w in queryset:
        key = w.key
        try:
            rebuild_wheel(w.company, key)
        except ValueError:
            messages.error(request, _(f"Clé inconnue pour {w}: {key}"))
    messages.success(request, _("Roue(s) régénérée(s)."))

@admin.action(description="Remettre le curseur (idx) à 0")
def action_reset_idx(modeladmin, request, queryset):
    for w in queryset:
        reset_wheel(w.company, w.key)
    messages.success(request, _("Curseur réinitialisé à 0 pour la sélection."))

@admin.register(ProbabilityWheel)
class ProbabilityWheelAdmin(admin.ModelAdmin):
    list_display = ("company", "key", "size", "idx")
    list_filter = ("company", "key")
    search_fields = ("company__name", "key")
    readonly_fields = ("size", "idx")
    actions = [action_ensure_wheels, action_rebuild_selected, action_reset_idx]
===== ./rewards/utils.py =====
from django import template
register = template.Library()

@register.filter
def get_item(d, key):
    try:
        return d.get(key)
    except Exception:
        return None
===== ./rewards/urls.py =====
# rewards/urls.py
from django.urls import path
from .views import (
    reward_list, reward_update, rewards_history_company, reward_spin,
    use_reward, distribute_reward, referral_delete,rewards_stats,test_wheel, reward_send_sms
)

app_name = "rewards"

urlpatterns = [
    path("", reward_list, name="list"),
    path("<int:pk>/edit/", reward_update, name="edit"),
    path("<int:pk>/update/", reward_update, name="update"), 
    path("history/", rewards_history_company, name="history_company"),
    path("stats/", rewards_stats, name="stats"),  
    path("spin/<int:reward_id>/", reward_spin, name="spin"),
    path("use/<str:token>/", use_reward, name="use_reward"),
    path("distribute/<int:pk>/", distribute_reward, name="distribute"),
    path("referral/<int:pk>/delete/", referral_delete, name="referral_delete"),
    path("test-wheel/", test_wheel, name="test_wheel"), 
    path("<int:pk>/send/sms/", reward_send_sms, name="reward_send_sms"),
    
]
===== ./rewards/notifications/services.py =====
# rewards/notifications/services.py
import os
from twilio.rest import Client as TwilioClient

def send_sms(to: str, body: str) -> tuple[bool, str | None]:
    """
    Envoie un SMS via Twilio.
    Retourne (True, None) si OK, sinon (False, "erreur ...").
    """
    sid = os.getenv("TWILIO_ACCOUNT_SID")
    token = os.getenv("TWILIO_AUTH_TOKEN")
    sender = os.getenv("TWILIO_FROM_NUMBER")
    if not (sid and token and sender):
        return False, "Configuration Twilio manquante (env: TWILIO_*)."
    if not to:
        return False, "Numéro du destinataire manquant."

    try:
        client = TwilioClient(sid, token)
        client.messages.create(to=to, from_=sender, body=body)
        return True, None
    except Exception as e:
        return False, str(e)
===== ./rewards/services/probabilities.py =====
# rewards/services/probabilities.py
from __future__ import annotations
from dataclasses import dataclass
from decimal import Decimal, getcontext
from typing import Dict, List, Tuple, Set

from django.db import transaction
from django.shortcuts import render

from accounts.models import Company
from rewards.models import ProbabilityWheel, RewardTemplate
from dashboard.models import Referral

# Compatibilité avec les anciens helpers/tests
from rewards.probabilities import (
    WheelSpec as _LegacyWheelSpec,
    ensure_wheel as _legacy_ensure_wheel,
    draw as _legacy_draw,
)


# Expose les symboles historiques
WheelSpec = _LegacyWheelSpec
ensure_wheel = _legacy_ensure_wheel
draw = _legacy_draw

# ------------------ Définition des deux roues “exactes” ------------------
BASE_KEY = "base_100"           # 1000 cases = 980/19/1
VERY_RARE_KEY = "very_rare_10000"  # 100_000 cases = 1 TRES_RARE

SOUVENT = "SOUVENT"
MOYEN = "MOYEN"
RARE = "RARE"
TRES_RARE = "TRES_RARE"
NO_HIT = "NO_HIT"

BASE_COUNTS = {SOUVENT: 980, MOYEN: 19, RARE: 1}
BASE_SIZE = sum(BASE_COUNTS.values())  # 1000

VR_COUNTS = {NO_HIT: 100_000 - 1, TRES_RARE: 1}
VR_SIZE = sum(VR_COUNTS.values())  # 100_000

getcontext().prec = 28  # précision si on affiche des pourcentages

def _build_base_pool() -> List[str]:
    pool: List[str] = []
    for token, n in BASE_COUNTS.items():
        pool.extend([token] * n)
    return pool

def _build_very_rare_pool() -> List[str]:
    pool: List[str] = []
    for token, n in VR_COUNTS.items():
        pool.extend([token] * n)
    return pool

@transaction.atomic
def ensure_wheels(company: Company) -> Tuple[ProbabilityWheel, ProbabilityWheel]:
    """
    Crée (ou met à niveau) les deux roues exactes pour l’entreprise.
    """
    base, _ = ProbabilityWheel.objects.get_or_create(
        company=company,
        key=BASE_KEY,
        defaults={"pool": _build_base_pool(), "size": BASE_SIZE, "idx": 0},
    )
    very_rare, _ = ProbabilityWheel.objects.get_or_create(
        company=company,
        key=VERY_RARE_KEY,
        defaults={"pool": _build_very_rare_pool(), "size": VR_SIZE, "idx": 0},
    )

    if base.size != BASE_SIZE:
        base.pool, base.size, base.idx = _build_base_pool(), BASE_SIZE, 0
        base.save(update_fields=["pool", "size", "idx"])

    if very_rare.size != VR_SIZE:
        very_rare.pool, very_rare.size, very_rare.idx = _build_very_rare_pool(), VR_SIZE, 0
        very_rare.save(update_fields=["pool", "size", "idx"])

    return base, very_rare

def rebuild_wheel(company: Company, key: str) -> None:
    if key == BASE_KEY:
        pool, size = _build_base_pool(), BASE_SIZE
    elif key == VERY_RARE_KEY:
        pool, size = _build_very_rare_pool(), VR_SIZE
    else:
        raise ValueError(f"Clé de roue inconnue: {key}")

    ProbabilityWheel.objects.update_or_create(
        company=company, key=key,
        defaults={"pool": pool, "size": size, "idx": 0}
    )

def reset_wheel(company: Company, key: str) -> None:
    wheel = ProbabilityWheel.objects.get(company=company, key=key)
    wheel.idx = 0
    wheel.save(update_fields=["idx"])

def _eligible_buckets_for(company: Company, client) -> Dict[str, bool]:
    """
    Détermine l'éligibilité par bucket pour un client, en fonction de son
    nombre de parrainages (en tant que parrain).
    """
    referrals_count = Referral.objects.filter(
        company=company, referrer=client
    ).count()

    tpls = {
        t.bucket: t
        for t in RewardTemplate.objects.filter(company=company).only(
            "bucket", "min_referrals_required"
        )
    }

    def is_ok(bucket: str) -> bool:
        tpl = tpls.get(bucket)
        if not tpl:
            return False
        return referrals_count >= int(tpl.min_referrals_required or 0)

    return {
        SOUVENT: bool(tpls.get(SOUVENT)),
        MOYEN:   bool(tpls.get(MOYEN)),
        RARE:    is_ok(RARE),
        TRES_RARE: is_ok(TRES_RARE),
    }

def _consume_one_eligible(wheel: ProbabilityWheel, allowed: Set[str]) -> str:
    """
    Consomme la roue en sautant les cases non autorisées.
    Normalisation implicite et déterminisme conservé.
    """
    if wheel.size == 0:
        raise ValueError("Roue vide")

    for _ in range(wheel.size):
        val = wheel.pool[wheel.idx]
        wheel.idx = (wheel.idx + 1) % wheel.size
        if val in allowed:
            wheel.save(update_fields=["idx"])
            return val

    # Rien d'autorisé trouvé sur un cycle complet
    wheel.save(update_fields=["idx"])
    return NO_HIT

def tirer_recompense(company: Company, client) -> str:
    """
    Tirage “client-aware” :
      1) very_rare : autorise TRES_RARE seulement si éligible (sinon NO_HIT).
      2) base      : autorise SOUVENT/MOYEN/RARE selon éligibilité.
    """
    elig = _eligible_buckets_for(company, client)
    base, very_rare = ensure_wheels(company)

    allowed_vr = {NO_HIT}
    if elig.get(TRES_RARE, False):
        allowed_vr.add(TRES_RARE)

    vr = _consume_one_eligible(very_rare, allowed_vr)
    if vr == TRES_RARE:
        return TRES_RARE

    allowed_base: Set[str] = set()
    if elig.get(SOUVENT, False): allowed_base.add(SOUVENT)
    if elig.get(MOYEN,   False): allowed_base.add(MOYEN)
    if elig.get(RARE,    False): allowed_base.add(RARE)
    if not allowed_base:
        allowed_base = {SOUVENT}

    return _consume_one_eligible(base, allowed_base)

# Ajoute ceci dans rewards/services/probabilities.py

from decimal import Decimal, getcontext  # tu l'as déjà en haut du fichier
getcontext().prec = 28  # pour éviter les erreurs d'arrondi

def get_normalized_percentages(company: Company, client) -> Dict[str, Decimal]:
    """
    Calcule les pourcentages affichés côté UI en partant des probabilités
    “canoniques” demandées (avant seuils) puis en RENORMALISANT pour que
    la somme fasse exactement 100, en tenant compte de l'éligibilité.
      - SOUVENT   = 80 / 100
      - MOYEN     = 19 / 100
      - RARE      = 0.99999 / 100
      - TRES_RARE = 1 / 100000
    """
    elig = _eligible_buckets_for(company, client)

    # Poids de base (sur [0..1])
    p_base = {
        SOUVENT: Decimal("80") / Decimal("100"),        # 0.80
        MOYEN:   Decimal("19") / Decimal("100"),        # 0.19
        RARE:    Decimal("0.99999") / Decimal("100"),   # 0.0099999
    }
    p_tr = {TRES_RARE: Decimal(1) / Decimal(100000)}     # 0.00001

    # Masse des catégories autorisées
    mass = Decimal(0)
    for b, p in p_base.items():
        if elig.get(b, False):
            mass += p
    if elig.get(TRES_RARE, False):
        mass += p_tr[TRES_RARE]

    # Aucun bucket autorisé -> fallback lisible
    if mass == 0:
        return {
            SOUVENT:   Decimal(100),
            MOYEN:     Decimal(0),
            RARE:      Decimal(0),
            TRES_RARE: Decimal(0),
        }

    # Renormalisation -> la somme fait exactement 100
    return {
        SOUVENT:   (p_base[SOUVENT] / mass) * Decimal(100) if elig.get(SOUVENT, False)   else Decimal(0),
        MOYEN:     (p_base[MOYEN]   / mass) * Decimal(100) if elig.get(MOYEN,   False)   else Decimal(0),
        RARE:      (p_base[RARE]    / mass) * Decimal(100) if elig.get(RARE,    False)   else Decimal(0),
        TRES_RARE: (p_tr[TRES_RARE] / mass) * Decimal(100) if elig.get(TRES_RARE, False) else Decimal(0),
    }


===== ./rewards/services/__init__.py =====
# rewards/services/__init__.py
from .core import create_reward_from_template, award_both_parties
===== ./rewards/services/core.py =====
# rewards/services/core.py
from datetime import timedelta
from django.db import transaction
from django.utils import timezone

from ..models import RewardTemplate, Reward  # ⬅️ import relatif (note les deux points)


def create_reward_from_template(*, company, client, tpl, referral=None, label=None) -> Reward:
    """
    Crée une Reward à partir d’un RewardTemplate en recopiant le cooldown_days.
    Idempotent ? -> Non. Si tu veux éviter les doublons, vérifie avant.
    """
    reward = Reward(
        company=company,
        client=client,
        referral=referral,
        label=label or tpl.label,
        bucket=tpl.bucket,
        cooldown_days=tpl.cooldown_days or 0,
        state="PENDING",
    )
    reward.ensure_token()
    # Optionnel : aligner expiration du lien sur le délai d’utilisation
    if reward.cooldown_days and not reward.token_expires_at:
        reward.token_expires_at = timezone.now() + timedelta(days=int(reward.cooldown_days))
    reward.save()
    return reward


@transaction.atomic
def award_both_parties(*, referral, bucket_referrer="SOUVENT", bucket_referee="SOUVENT"):
    """
    Attribue une récompense au parrain ET au filleul pour un même Referral.
    - Par défaut, même bucket pour les deux ('SOUVENT'). Change si besoin.
    - Idempotent au niveau (company, client, referral) grâce à une vérif avant création.
    """
    company = referral.company
    referrer = referral.referrer
    referee = referral.referee

    # Choix des templates (tu peux changer la logique de sélection ici)
    tpl_referrer = RewardTemplate.objects.get(company=company, bucket=bucket_referrer)
    tpl_referee  = RewardTemplate.objects.get(company=company, bucket=bucket_referee)

    # Évite doublons : unique (company, client, referral)
    reward_referrer = Reward.objects.filter(company=company, client=referrer, referral=referral).first()
    if not reward_referrer:
        reward_referrer = create_reward_from_template(
            company=company, client=referrer, tpl=tpl_referrer, referral=referral
        )

    reward_referee = Reward.objects.filter(company=company, client=referee, referral=referral).first()
    if not reward_referee:
        reward_referee = create_reward_from_template(
            company=company, client=referee, tpl=tpl_referee, referral=referral
        )

    return reward_referrer, reward_referee
===== ./rewards/services/smsmode.py =====
# rewards/services/smsmode.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, Optional
import json
import logging
import re
import requests
from django.conf import settings

logger = logging.getLogger(__name__)

# =========================
# Modèles de données
# =========================

@dataclass
class SMSPayload:
    to: str
    text: str
    sender: Optional[str] = None

@dataclass
class SMSResult:
    ok: bool
    provider_id: Optional[str]
    status: str
    raw: Dict[str, Any]

# =========================
# Normalisation E.164 (FR + DROM + HT)
# =========================

E164_RE = re.compile(r"^\+\d{6,15}$")

def _digits_plus(s: str) -> str:
    """Garde uniquement chiffres et +."""
    return re.sub(r"[^\d\+]", "", s or "")

def normalize_msisdn(phone: str) -> str:
    """
    Normalise en E.164 pour :
      - France métropolitaine : 0X XX XX XX XX  -> +33 X...
      - Guadeloupe : 0590/0690 -> +590590... / +590690...
      - Martinique : 0596/0696 -> +596596... / +596696...
      - Guyane : 0594/0694     -> +594594... / +594694...
      - La Réunion : 0262/0692/0693 -> +262262... / +262692... / +262693...
      - Mayotte : 0269/0639        -> +262269... / +262639...
      - Haïti : 8 chiffres locaux  -> +509XXXXXXXX
    Règles :
      - '00' prefix => remplacé par '+'
      - si déjà E.164, renvoyé tel quel
      - si commence par indicatif sans '+', on ajoute '+'
    """
    raw = (phone or "").strip()
    p = _digits_plus(raw).replace(" ", "")

    # 00 => +
    if p.startswith("00"):
        p = "+" + p[2:]

    # déjà E.164 ?
    if E164_RE.match(p):
        return p

    # indicatifs DOM/HT sans '+'
    for cc in ("590", "596", "594", "262", "509"):
        if p.startswith(cc) and p[len(cc):].isdigit():
            return f"+{p}"

    # France/DOM formats nationaux (10 chiffres, commence par 0)
    if p.startswith("0") and len(p) == 10 and p.isdigit():
        n = p[1:]  # sans le 0
        # DOM fixes/mobiles
        if n.startswith(("590", "690")):  # Guadeloupe
            return f"+590{n}"
        if n.startswith(("596", "696")):  # Martinique
            return f"+596{n}"
        if n.startswith(("594", "694")):  # Guyane
            return f"+594{n}"
        if n.startswith(("262", "692", "693")):  # Réunion
            return f"+262{n}"
        if n.startswith(("269", "639")):  # Mayotte
            return f"+262{n}"  # E.164 Mayotte utilise +262

        # Métropole
        if n[0] in "12345":      # 01..05 -> +331..+335
            return f"+33{n[0]}{n[1:]}"
        if n[0] == "6":          # 06 -> +336
            return f"+33{n}"
        if n[0] == "7":          # 07 -> +337
            return f"+33{n}"

    # Haïti local sans trunk (8 chiffres)
    if len(p) == 8 and p.isdigit():
        return f"+509{p}"

    # 9 chiffres commençant par indicatifs DOM
    if len(p) == 9 and p.isdigit():
        if p.startswith(("590", "596", "594", "262")):
            return f"+{p[:3]}{p}"
        if p.startswith("690"):
            return f"+590{p}"
        if p.startswith("696"):
            return f"+596{p}"
        if p.startswith("694"):
            return f"+594{p}"
        if p.startswith(("692", "693")):
            return f"+262{p}"
        if p.startswith(("269", "639")):
            return f"+262{p}"

    # 9 chiffres métropole mobiles sans 0
    if len(p) == 9 and p.isdigit() and p[0] in ("6", "7"):
        return f"+33{p}"

    # Rien de concluant => renvoyer brut (le provider peut refuser si invalide)
    return raw

# =========================
# Message métier
# =========================

def build_reward_sms_text(*, client_fullname: str, claim_absolute_url: str, company_name: str | None) -> str:
    parts = []
    parts.append(f"{company_name}:" if company_name else "Votre récompense :")
    parts.append(
        f"{client_fullname}, vous avez une récompense en attente."
        if client_fullname else
        "Vous avez une récompense en attente."
    )
    parts.append(f"Utilisez-la ici : {claim_absolute_url}")
    return " ".join(parts)

# =========================
# Construction d'URL smsmode
# =========================

def _build_smsmode_url() -> str:
    """
    Construit l'URL finale sans double 'sms/v1'.
    - Si BASE_URL se termine déjà par '/sms/v1' => ajoute '/messages'
    - Sinon => ajoute '/sms/v1/messages'
    """
    base = settings.SMSMODE["BASE_URL"].rstrip("/")  # ex: https://rest.smsmode.com
    if base.endswith("/sms/v1"):
        return f"{base}/messages"
    return f"{base}/sms/v1/messages"

# =========================
# Envoi
# =========================

def send_sms(payload: SMSPayload) -> SMSResult:
    """
    Envoi via smsmode.
    Auth: header 'X-Api-Key: <API_KEY>'
    Endpoint attendu: https://rest.smsmode.com/sms/v1/messages

    Corps JSON (conforme smsmode):
      {
        "recipient": {"to": "+33XXXXXXXXX"},
        "body": {"text": "message"},
        "from": "ParrainApp"  # optionnel selon contrat
      }
    """
    if settings.SMSMODE.get("DRY_RUN"):
        logger.info("[SMSMODE DRY-RUN] %s", payload)
        return SMSResult(ok=True, provider_id=None, status="DRY_RUN", raw={"dry_run": True})

    url = _build_smsmode_url()

    headers = {
        "X-Api-Key": settings.SMSMODE["API_KEY"],   # ✅ auth correcte
        "Content-Type": "application/json",
        "Accept": "application/json",
    }

    data: Dict[str, Any] = {
        "recipient": {"to": payload.to},   # <- champ attendu
        "body": {"text": payload.text},    # <- champ attendu
    }
    if payload.sender:
        data["from"] = payload.sender      # optionnel selon votre contrat

    logger.info("SMSMODE POST %s to=%s sender=%s", url, payload.to, payload.sender or "")

    try:
        resp = requests.post(url, headers=headers, data=json.dumps(data), timeout=settings.SMSMODE["TIMEOUT"])
        ctype = (resp.headers.get("Content-Type") or "").lower()
        raw: Dict[str, Any] = resp.json() if "application/json" in ctype else {"text": resp.text}
        ok = 200 <= resp.status_code < 300

        # id de message (peut être messageId ou messageIds[])
        provider_id: Optional[str] = None
        if isinstance(raw.get("messageIds"), list) and raw["messageIds"]:
            provider_id = raw["messageIds"][0]
        else:
            provider_id = raw.get("messageId")

        status = raw.get("status") or ("OK" if ok else f"HTTP_{resp.status_code}")
        if not ok:
            logger.error("SMSMODE error: %s (status=%s url=%s)", raw, resp.status_code, url)

        return SMSResult(ok=ok, provider_id=provider_id, status=status, raw=raw)

    except Exception as e:
        logger.exception("SMSMODE exception")
        return SMSResult(ok=False, provider_id=None, status=f"EXC:{e}", raw={})
===== ./rewards/views.py =====
# rewards/views.py
from __future__ import annotations

from datetime import date
from decimal import Decimal
import random
import secrets

from django.conf import settings
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.core.exceptions import PermissionDenied
from django.core.paginator import Paginator
from django.db import transaction
from django.db.models import Q, Count
from django.db.models.functions import TruncMonth
from django.http import Http404
from django.shortcuts import render, redirect, get_object_or_404
from django.utils import timezone
from django.views.decorators.http import require_POST

from accounts.models import Company
from dashboard.models import Referral
from .models import RewardTemplate, Reward, ProbabilityWheel
from .forms import RewardTemplateForm
from rewards.services.probabilities import BASE_COUNTS, VR_COUNTS, BASE_SIZE, VR_SIZE
from .services.smsmode import SMSPayload, send_sms, build_reward_sms_text, normalize_msisdn


# ----------------------------- UI Dictionaries -----------------------------

BUCKET_UI = {
    "SOUVENT":   {"label": "Souvent",   "badge": "success", "prob": "980/1000"},
    "MOYEN":     {"label": "Moyen",     "badge": "info",    "prob": "19/1000"},
    "RARE":      {"label": "Rare",      "badge": "warning", "prob": "1/1000"},
    "TRES_RARE": {"label": "Très rare", "badge": "danger",  "prob": "1/100000"},
}

STATE_UI = {
    "PENDING":  {"label": "En attente",   "badge": "warning"},
    "SENT":     {"label": "Envoyée",      "badge": "success"},
    "DISABLED": {"label": "Désactivée",   "badge": "secondary"},
    "ARCHIVED": {"label": "Archivée",     "badge": "dark"},
}


# ----------------------------- Helpers généraux -----------------------------

def _is_superadmin(u) -> bool:
    return hasattr(u, "is_superadmin") and u.is_superadmin()

def _company_for(u):
    return getattr(u, "company", None)

def _current_company(request, *, allow_default_for_superadmin: bool = True) -> Company | None:
    """
    Admin/Opérateur : user.company
    Superadmin :
      - si ?company=… fourni → utilise cet id (string possible)
      - sinon id mémorisé en session (souvent un int)
      - sinon (si allow_default_for_superadmin) → 1ʳᵉ entreprise
    """
    user = request.user

    # Cas Admin/Opérateur : on retourne simplement son entreprise
    if not _is_superadmin(user):
        return getattr(user, "company", None)

    # ---- Superadmin : on lit d'abord le GET (string) puis la session (int) ----
    raw_cid = request.GET.get("company")
    if isinstance(raw_cid, str):
        raw_cid = raw_cid.strip()
    if not raw_cid:
        raw_cid = request.session.get("dash_company_id")  # peut être un int

    # On résout l'entreprise (Django accepte int/str pour pk)
    company = Company.objects.filter(pk=raw_cid).first() if raw_cid else None
    if company:
        request.session["dash_company_id"] = company.id  # on stocke proprement l'int
        return company

    # Fallback : 1ʳᵉ entreprise (si autorisé)
    if allow_default_for_superadmin:
        company = Company.objects.order_by("name").first()
        if company:
            request.session["dash_company_id"] = company.id
        return company

    return None


def _can_manage_company(user, company) -> bool:
    return _is_superadmin(user) or (getattr(user, "company_id", None) == company.id)


def ensure_reward_templates(company: Company):
    """
    Crée les 4 templates si manquants, avec probas affichées figées.
    (Utilisé pour un écran mono-entreprise : liste/édition des templates)
    """
    defaults_map = {
        "SOUVENT":   {"label": "- 10 % de remise", "cooldown_months": 1},
        "MOYEN":     {"label": "- 10 % de remise", "cooldown_months": 1},
        "RARE":      {"label": "iPhone 16 Pro Max", "cooldown_months": 3},
        "TRES_RARE": {"label": "Voyage à Miami", "cooldown_months": 6},
    }
    for key, ui in BUCKET_UI.items():
        obj, _created = RewardTemplate.objects.get_or_create(
            company=company, bucket=key,
            defaults={
                **defaults_map[key],
                "probability_display": ui["prob"],
                "min_referrals_required": 0,
            }
        )
        if not obj.probability_display:
            obj.probability_display = ui["prob"]
            obj.save(update_fields=["probability_display"])


def _last_12_month_starts(today):
    """
    Retourne la liste des 12 premiers jours de mois (du plus ancien au plus récent).
    """
    y, m = today.year, today.month
    out = []
    for i in range(11, -1, -1):
        yy, mm = y, m - i
        while mm <= 0:
            mm += 12
            yy -= 1
        out.append(date(yy, mm, 1))
    return out


# ----------------------------- Snapshot des roues (local) -----------------------------
# Clés/tokens alignés avec rewards/probabilities.py
_BASE_KEY = "base_100"
_VERY_RARE_KEY = "very_rare_10000"

_TOK_BASE = ["SOUVENT", "MOYEN", "RARE"]
_TOK_VR   = ["TRES_RARE", "NO_HIT"]


def _remaining_counts(pool, idx, tokens):
    """Compte ce qu'il reste AVANT la fin du cycle actuel (de idx -> fin)."""
    tail = pool[idx:] if pool and 0 <= idx < len(pool) else pool
    out = {}
    for t in tokens:
        out[t] = tail.count(t) if tail else 0
    return out


def _wheels_snapshot(company: Company):
    """
    Renvoie un dict:
    {
      "base":      {"size": int, "idx": int, "progress_pct": int,
                    "remaining_by_token": {token: n}, "total_by_token": {token: n}},
      "very_rare": { ... }
    }
    Si une roue n'existe pas encore, on renvoie des zéros élégants.
    """
    snap = {}
    # --- BASE ---
    try:
        base = ProbabilityWheel.objects.get(company=company, key=_BASE_KEY)
        base_total = {t: base.pool.count(t) for t in _TOK_BASE}
        base_remaining = _remaining_counts(base.pool, base.idx, _TOK_BASE)
        base_progress = int((base.idx / base.size) * 100) if base.size else 0
        snap["base"] = {
            "size": base.size,
            "idx": base.idx,
            "progress_pct": base_progress,
            "remaining_by_token": base_remaining,
            "total_by_token": base_total,
        }
    except ProbabilityWheel.DoesNotExist:
        snap["base"] = {
            "size": 0,
            "idx": 0,
            "progress_pct": 0,
            "remaining_by_token": {t: 0 for t in _TOK_BASE},
            "total_by_token": {t: 0 for t in _TOK_BASE},
        }

    # --- VERY RARE ---
    try:
        vr = ProbabilityWheel.objects.get(company=company, key=_VERY_RARE_KEY)
        vr_total = {t: vr.pool.count(t) for t in _TOK_VR}
        vr_remaining = _remaining_counts(vr.pool, vr.idx, _TOK_VR)
        vr_progress = int((vr.idx / vr.size) * 100) if vr.size else 0
        snap["very_rare"] = {
            "size": vr.size,
            "idx": vr.idx,
            "progress_pct": vr_progress,
            "remaining_by_token": vr_remaining,
            "total_by_token": vr_total,
        }
    except ProbabilityWheel.DoesNotExist:
        snap["very_rare"] = {
            "size": 0,
            "idx": 0,
            "progress_pct": 0,
            "remaining_by_token": {t: 0 for t in _TOK_VR},
            "total_by_token": {t: 0 for t in _TOK_VR},
        }

    return snap


# ----------------------------- CRUD Templates -----------------------------

@login_required
def reward_list(request):
    """
    Écran de gestion des templates de récompenses.
    - Admin/Opérateur : sur son entreprise.
    - Superadmin : PAS de choix requis → on prend automatiquement la 1ʳᵉ entreprise
      (ou celle passée en ?company=... si présent).
    """
    company = _current_company(request, allow_default_for_superadmin=True)
    if not company:
        # Cas extrême : aucune entreprise en base
        messages.info(request, "Aucune entreprise disponible.")
        return render(request, "rewards/list.html", {"items": [], "TEST_WHEEL": None, "company": None})

    # S’assure que les 4 templates existent pour cette entreprise (mono-contexte)
    ensure_reward_templates(company)

    # 1) Récupérer les templates
    qs = RewardTemplate.objects.filter(company=company)

    # 2) Trier par bucket (SOUVENT -> MOYEN -> RARE -> TRES_RARE)
    order = {"SOUVENT": 0, "MOYEN": 1, "RARE": 2, "TRES_RARE": 3}
    items_sorted = sorted(qs, key=lambda tpl: order.get(tpl.bucket, 99))

    # 3) Préparer l'affichage (paire (template, ui))
    items = [(tpl, BUCKET_UI[tpl.bucket]) for tpl in items_sorted]

    # 4) Données de la roue de test (probas identiques à Reward)
    test_wheel = {
        "base": {"size": BASE_SIZE, "counts": BASE_COUNTS},
        "very_rare": {"size": VR_SIZE, "counts": VR_COUNTS},
    }

    return render(request, "rewards/list.html", {
        "company": company,
        "items": items,
        "TEST_WHEEL": test_wheel,
        "is_superadmin": _is_superadmin(request.user),
    })


@login_required
def reward_update(request, pk):
    company = _current_company(request, allow_default_for_superadmin=True)
    r = get_object_or_404(RewardTemplate, pk=pk, company=company)
    if request.method == "POST":
        form = RewardTemplateForm(request.POST, instance=r)
        if form.is_valid():
            form.save()
            messages.success(request, "Récompense mise à jour.")
            return redirect("rewards:list")
    else:
        form = RewardTemplateForm(instance=r)
    return render(request, "rewards/form.html", {"form": form, "tpl": r, "ui": BUCKET_UI[r.bucket], "company": company})


# ------------------------------ Historique (entreprise / global) ------------------------------

@login_required
def rewards_history_company(request):
    """
    Historique des récompenses.
    - Superadmin SANS ?company=… : historique GLOBAL (toutes entreprises).
    - Sinon : historique filtré par entreprise.
    """
    user = request.user

    base_qs = (
        Reward.objects
        .select_related("company", "client", "referral", "referral__referrer", "referral__referee")
        .order_by("-created_at", "-id")
    )

    # ---- Global si Superadmin sans paramètre ----
    if _is_superadmin(user) and not request.GET.get("company"):
        qs = base_qs
        company = None
        scope_label = "GLOBAL"
    else:
        company = _current_company(request)  # comportement existant conservé
        if not company:
            messages.error(request, "Aucune entreprise sélectionnée.")
            return redirect("dashboard:root")
        qs = base_qs.filter(company=company)
        scope_label = company.name

    # Filtres UI
    bucket = (request.GET.get("bucket") or "").strip().upper()
    state  = (request.GET.get("state") or "").strip().upper()
    q      = (request.GET.get("q") or "").strip()

    if bucket in BUCKET_UI:
        qs = qs.filter(bucket=bucket)
    if state in STATE_UI:
        qs = qs.filter(state=state)
    if q:
        qs = qs.filter(
            Q(client__first_name__icontains=q) |
            Q(client__last_name__icontains=q)  |
            Q(client__email__icontains=q)      |
            Q(label__icontains=q)
        )

    page = Paginator(qs, 20).get_page(request.GET.get("p"))

    return render(request, "rewards/history.html", {
        "company": company,                # None en mode global
        "scope_label": scope_label,        # "GLOBAL" ou nom d’entreprise
        "page": page,
        "bucket": bucket,
        "state": state,
        "q": q,
        "BUCKET_UI": BUCKET_UI,
        "STATE_UI": STATE_UI,
        "buckets": [(k, v["label"]) for k, v in BUCKET_UI.items()],
        "states": [(k, v["label"]) for k, v in STATE_UI.items()],
        "is_superadmin": _is_superadmin(user),
    })

# ------------------------------ Spin (animation) ------------------------------

@login_required
def reward_spin(request, reward_id: int):
    reward = get_object_or_404(
        Reward.objects.select_related("company", "client"),
        pk=reward_id
    )

    wheel_order = ["SOUVENT", "MOYEN", "RARE", "TRES_RARE"]
    segment = 360 / len(wheel_order)  # 90°
    try:
        idx = wheel_order.index(reward.bucket)
    except ValueError:
        idx = 0
    target_angle = 4 * 360 + int(idx * segment + segment / 2)

    ui = BUCKET_UI.get(reward.bucket, {"label": reward.bucket, "badge": "secondary"})
    return render(request, "rewards/spin.html", {
        "reward": reward,
        "ui": ui,
        "target_angle": target_angle,
    })


# ------------------------------ Page publique (token) ------------------------------

def use_reward(request, token):
    """
    Page publique d'une récompense (par token) avec un rendu "joli".
    AUCUN changement de logique métier : on enrichit juste le contexte.
    """
    reward = get_object_or_404(
        Reward.objects.select_related(
            "company", "client", "referral", "referral__referrer", "referral__referee"
        ),
        token=token,
    )

    # Message informatif si la récompense n'est plus en attente
    if reward.state != "PENDING":
        messages.info(
            request,
            "Cette récompense n’est plus en attente (déjà distribuée ou inactive)."
        )

    # Données d'en-tête
    company_name = (getattr(reward.company, "name", "") or "").strip()
    client_name  = (reward.client.first_name or reward.client.last_name or "").strip()

    # Si la récompense provient d'un parrainage, on personnalise :
    is_ref = bool(reward.referral_id)
    is_referrer = is_ref and reward.client_id == reward.referral.referrer_id
    is_referee  = is_ref and reward.client_id == reward.referral.referee_id

    referrer_name = ""
    referee_name  = ""
    if is_ref:
        referrer_name = (reward.referral.referrer.first_name or reward.referral.referrer.last_name or "").strip()
        referee_name  = (reward.referral.referee.first_name  or reward.referral.referee.last_name  or "").strip()

    # Phrases d'accroche (comme sur la maquette)
    if is_referrer:
        headline  = f"Félicitations {client_name} !" if client_name else "Félicitations !"
        celebrate = f"Tu as fait découvrir {company_name} à {referee_name}".strip()
        subline   = "Voici ton cadeau 🎁"
        ribbon    = f"Parrainage validé grâce à {referee_name}".strip()
    elif is_referee:
        headline  = f"Bienvenue {client_name} !" if client_name else "Bienvenue !"
        celebrate = f"Parrainage validé grâce à {referrer_name}".strip()
        subline   = "Voici ton cadeau 🎁"
        ribbon    = "Ton cadeau"
    else:
        headline  = f"Félicitations {client_name} !" if client_name else "Félicitations !"
        celebrate = company_name
        subline   = "Voici ton cadeau 🎁"
        ribbon    = "Ton cadeau"

    claim_absolute = request.build_absolute_uri(reward.claim_path) if reward.claim_path else ""

    context = {
        "reward": reward,
        "headline": headline,
        "celebrate": celebrate,
        "subline": subline,
        "ribbon": ribbon,
        "company_name": company_name,
        "claim_absolute": claim_absolute,
    }
    return render(request, "rewards/use_reward.html", context)


# ------------------------------ Actions ------------------------------

@login_required
@require_POST
def distribute_reward(request, pk: int):
    reward = get_object_or_404(
        Reward.objects.select_related("company", "client"),
        pk=pk
    )

    if not _can_manage_company(request.user, reward.company):
        messages.error(request, "Accès refusé.")
        back_id = request.POST.get("back_client")
        return redirect("dashboard:client_detail", pk=back_id) if back_id else redirect("dashboard:clients_list")

    if reward.state != "PENDING":
        messages.info(request, "La récompense n’est pas en attente (déjà traitée ?).")
    else:
        reward.state = "SENT"
        reward.redeemed_at = timezone.now()
        reward.save(update_fields=["state", "redeemed_at"])
        messages.success(request, f"Récompense « {reward.label} » distribuée.")

    back_id = request.POST.get("back_client")
    return redirect("dashboard:client_detail", pk=back_id) if back_id else redirect("rewards:history_company")


@login_required
@require_POST
def referral_delete(request, pk: int):
    referral = get_object_or_404(
        Referral.objects.select_related("company", "referrer", "referee"),
        pk=pk
    )

    if not _can_manage_company(request.user, referral.company):
        messages.error(request, "Accès refusé.")
        back_id = request.POST.get("back_client")
        return redirect("dashboard:client_detail", pk=back_id) if back_id else redirect("dashboard:clients_list")

    back_client_id = request.POST.get("back_client") or referral.referee_id or referral.referrer_id

    referral.delete()
    messages.success(request, "Parrainage supprimé.")
    return redirect("dashboard:client_detail", pk=back_client_id)


# ------------------------------ STATS (récompenses) ------------------------------

@login_required
def rewards_stats(request):
    """
    Superadmin sans ?company=... => stats GLOBAL (toutes entreprises)
    Sinon => stats bornées à l’entreprise courante.
    """
    user = request.user

    # ---- Superadmin GLOBAL (on n'utilise pas _current_company ici) ----
    if _is_superadmin(user) and not request.GET.get("company"):
        # Période (4 derniers mois)
        def _last_n_month_starts(today, n):
            y, m = today.year, today.month
            out = []
            for i in range(n - 1, -1, -1):
                yy, mm = y, m - i
                while mm <= 0:
                    mm += 12
                    yy -= 1
                out.append(date(yy, mm, 1))
            return out

        today = timezone.now().date().replace(day=1)
        months = _last_n_month_starts(today, 4)

        qs_all = Reward.objects.all()

        monthly_raw = (
            qs_all.annotate(m=TruncMonth("created_at"))
                  .values("m").annotate(n=Count("id")).order_by("m")
        )
        monthly_map = {row["m"].date(): row["n"] for row in monthly_raw if row["m"]}
        monthly_rows = [{"month": m, "n": monthly_map.get(m, 0)} for m in months]
        max_n = max([r["n"] for r in monthly_rows] or [1])
        for r in monthly_rows:
            r["pct"] = int((r["n"] / max_n) * 100) if max_n else 0

        gifts_raw = list(qs_all.values("label").annotate(n=Count("id")).order_by("-n")[:4])
        total_gifts = sum(g["n"] for g in gifts_raw) or 1
        top_gifts = [
            {"label": g["label"] or "—", "n": g["n"], "pct": int((g["n"] / total_gifts) * 100)}
            for g in gifts_raw
        ]

        # KPI + tableau par entreprise
        rows = []
        totals = {"rewards_sent": 0, "rewards_pending": 0, "clients": 0, "referrals_month": 0}
        month_start = timezone.now().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        for c in Company.objects.all().order_by("name"):
            r_sent = Reward.objects.filter(company=c, state="SENT").count()
            r_pend = Reward.objects.filter(company=c, state="PENDING").count()
            n_clients = c.client_set.count() if hasattr(c, "client_set") else 0
            n_ref_month = Referral.objects.filter(company=c, created_at__gte=month_start).count()
            rows.append({
                "company": c,
                "rewards_sent": r_sent,
                "rewards_pending": r_pend,
                "clients": n_clients,
                "referrals_month": n_ref_month,
            })
            totals["rewards_sent"] += r_sent
            totals["rewards_pending"] += r_pend
            totals["clients"] += n_clients
            totals["referrals_month"] += n_ref_month

        return render(request, "rewards/stats.html", {
            "company": None,              # important : pas d’entreprise sélectionnée
            "is_superadmin": True,
            "monthly_rows": monthly_rows,
            "top_gifts": top_gifts,
            "global_rows": rows,          # tableau par entreprise
            "global_kpi": totals,         # totaux globaux
        })

    # ---- Entreprise (Admin/Opérateur OU Superadmin avec ?company=...) ----
    company = _current_company(request)  # comportement existant conservé
    if not company:
        messages.error(request, "Aucune entreprise sélectionnée.")
        return redirect("dashboard:root")

    qs = Reward.objects.filter(company=company)

    # 4 derniers mois
    def _last_n_month_starts(today, n):
        y, m = today.year, today.month
        out = []
        for i in range(n - 1, -1, -1):
            yy, mm = y, m - i
            while mm <= 0:
                mm += 12
                yy -= 1
            out.append(date(yy, mm, 1))
        return out

    today = timezone.now().date().replace(day=1)
    months = _last_n_month_starts(today, 4)

    monthly_raw = (
        qs.annotate(m=TruncMonth("created_at"))
          .values("m").annotate(n=Count("id")).order_by("m")
    )
    monthly_map = {row["m"].date(): row["n"] for row in monthly_raw if row["m"]}
    monthly_rows = [{"month": m, "n": monthly_map.get(m, 0)} for m in months]
    max_n = max([r["n"] for r in monthly_rows] or [1])
    for r in monthly_rows:
        r["pct"] = int((r["n"] / max_n) * 100) if max_n else 0

    gifts_raw = list(qs.values("label").annotate(n=Count("id")).order_by("-n")[:4])
    total_gifts = sum(g["n"] for g in gifts_raw) or 1
    top_gifts = [
        {"label": g["label"] or "—", "n": g["n"], "pct": int((g["n"] / total_gifts) * 100)}
        for g in gifts_raw
    ]

    return render(request, "rewards/stats.html", {
        "company": company,
        "is_superadmin": _is_superadmin(user),
        "monthly_rows": monthly_rows,
        "top_gifts": top_gifts,
    })


# ------------------------------ Roue de test (sans attribution) ------------------------------

@login_required
def test_wheel(request):
    """
    Roue de test (sans attribution).

    Probabilités « de base » (sans minimums) :
      - SOUVENT   = 80 / 100
      - MOYEN     = 19 / 100
      - RARE      = 0,99999 / 100
      - TRES_RARE = 1 / 100000

    Modes :
      - combined (défaut) : test TRES_RARE (1/100000), sinon base 80/19/~1%
      - base              : uniquement SOUVENT/MOYEN/RARE
      - very_rare         : TRES_RARE vs NO_HIT
    GET:
      - n    : simuler N tirages
      - seed : graine RNG (reproductible)
      - mode : combined | base | very_rare
    """
    mode = (request.GET.get("mode") or "combined").lower()
    simulate_n = int(request.GET.get("n") or 0)
    seed = request.GET.get("seed")
    rng = random.Random(seed) if seed else random

    # Probabilités demandées
    P_S  = Decimal("80") / Decimal("100")        # 0.80
    P_M  = Decimal("19") / Decimal("100")        # 0.19
    P_R  = Decimal("0.99999") / Decimal("100")   # 0.0099999
    P_TR = Decimal(1) / Decimal(100000)          # 0.00001

    ORDER = ("SOUVENT", "MOYEN", "RARE", "TRES_RARE", "NO_HIT")

    # ---- Tirage 1 coup (pour l’animation) : pondération simple ----
    def weighted_choice(weights: dict[str, Decimal]) -> str:
        total = float(sum(weights.values())) or 1.0
        x = rng.random() * total
        acc = 0.0
        for k in ORDER:
            if k in weights:
                acc += float(weights[k])
                if x < acc:
                    return k
        return next(iter(weights))

    def draw_once() -> str:
        if mode == "very_rare":
            return weighted_choice({"TRES_RARE": P_TR, "NO_HIT": Decimal(1) - P_TR})
        if mode == "base":
            return weighted_choice({"SOUVENT": P_S, "MOYEN": P_M, "RARE": P_R})
        # combined
        if rng.random() < float(P_TR):
            return "TRES_RARE"
        return weighted_choice({"SOUVENT": P_S, "MOYEN": P_M, "RARE": P_R})

    bucket = draw_once()

    # ---- Simulation N tirages (sans remise pour respecter 80/19/1 sur 100) ----
    counts = pct = None
    if simulate_n > 0:
        counts = {"SOUVENT": 0, "MOYEN": 0, "RARE": 0, "TRES_RARE": 0, "NO_HIT": 0}

        if mode == "very_rare":
            # N essais indépendants de proba 1/100000
            for _ in range(simulate_n):
                if rng.random() < float(P_TR):
                    counts["TRES_RARE"] += 1
                else:
                    counts["NO_HIT"] += 1

        else:
            # Base « exacte » : cycles de 100 cases (80/19/1), échantillonnage sans remise.
            full_cycles, rem = divmod(simulate_n, 100)
            counts["SOUVENT"] += 80 * full_cycles
            counts["MOYEN"]   += 19 * full_cycles
            counts["RARE"]    += 1  * full_cycles

            if rem:
                base_pool = ["SOUVENT"] * 80 + ["MOYEN"] * 19 + ["RARE"] * 1
                rng.shuffle(base_pool)
                for t in base_pool[:rem]:
                    counts[t] += 1

            if mode == "combined":
                # Injecte les très rares (très improbable sur 100 tirages)
                # On convertit autant de tirages base en TRES_RARE pour rester à N total.
                vr_hits = sum(1 for _ in range(simulate_n) if rng.random() < float(P_TR))
                for _ in range(vr_hits):
                    base_list = (
                        ["SOUVENT"] * counts["SOUVENT"] +
                        ["MOYEN"]   * counts["MOYEN"]   +
                        ["RARE"]    * counts["RARE"]
                    )
                    if base_list:
                        t = rng.choice(base_list)
                        counts[t] -= 1
                    counts["TRES_RARE"] += 1

        total = sum(counts.values()) or 1
        pct = {k: round(counts[k] * 100 / total, 2) for k in counts}

    # ---- UI / animation ----
    ui = BUCKET_UI.get(bucket, {"label": "Aucun gain", "badge": "secondary"})
    wheel_order = ["SOUVENT", "MOYEN", "RARE", "TRES_RARE"]
    seg = 360 / len(wheel_order)
    idx = wheel_order.index(bucket) if bucket in wheel_order else 0
    target_angle = 4 * 360 + int(idx * seg + seg / 2)

    return render(request, "rewards/test_wheel.html", {
        "bucket": bucket,
        "ui": ui,
        "target_angle": target_angle,
        "mode": mode,
        "seed": seed or "",
        "simulate_n": simulate_n,
        "counts": counts,
        "pct": pct,
    })


# ------------------------------ Envoi SMS lien de récompense ------------------------------

@login_required
@require_POST
def reward_send_sms(request, pk: int):
    """
    Envoie au client un SMS contenant le lien d’utilisation de la récompense (token).
    POST /rewards/<pk>/send/sms/
    """
    reward = get_object_or_404(Reward.objects.select_related("client", "company"), pk=pk)

    # --- Permissions (mêmes règles que distribute_reward) ---
    user = request.user
    if _is_superadmin(user):
        pass
    elif getattr(user, "company_id", None) and reward.company_id == user.company_id:
        pass
    else:
        raise Http404("Non autorisé")

    # Génère un token s’il n’existe pas encore (pour construire l’URL)
    reward.ensure_token()
    reward.save(update_fields=["token", "token_expires_at"])

    # Données pour le SMS
    claim_absolute = request.build_absolute_uri(reward.claim_path)
    client_fullname = f"{reward.client.first_name} {reward.client.last_name}".strip()
    company_name = getattr(reward.company, "name", None)

    phone = normalize_msisdn(reward.client.phone or "")
    if not phone:
        messages.error(request, "Le client n’a pas de numéro de téléphone valide.")
        back_id = request.POST.get("back_client")
        return redirect("dashboard:client_detail", pk=back_id) if back_id else redirect("dashboard:clients_list")

    text = build_reward_sms_text(
        client_fullname=client_fullname,
        claim_absolute_url=claim_absolute,
        company_name=company_name,
    )

    payload = SMSPayload(to=phone, text=text, sender=settings.SMSMODE.get("SENDER") or None)
    result = send_sms(payload)

    if result.ok:
        messages.success(request, "SMS envoyé au client.")
    else:
        messages.error(request, f"Échec d’envoi SMS ({result.status}).")

    back_id = request.POST.get("back_client")
    return redirect("dashboard:client_detail", pk=back_id) if back_id else redirect("rewards:history_company")
===== ./templates/rewards/form.html =====
{# templates/rewards/form.html #}
{% extends "base_dashboard.html" %}
{% block title %}Modifier une récompense • ParrainApp{% endblock %}
{% block body_data_page %}recompenses{% endblock %}

{% block content %}
<header class="mb-3">
  <h1 class="h4 section-title mb-1">Modifier « {{ tpl.label }} » ({{ ui.label }})</h1>
  <div class="text-secondary">Probabilité : ~{{ tpl.probability_display }} (fixe)</div>
</header>

<div class="card shadow-sm">
  <form method="post" class="card-body vstack gap-3">
    {% csrf_token %}

    <div class="row g-3">
      <div class="col-md-6">
        <label for="{{ form.label.id_for_label }}" class="form-label">Nom de la récompense</label>
        {{ form.label }}
      </div>

      <div class="col-md-3">
        <label for="{{ form.cooldown_months.id_for_label }}" class="form-label">Délai</label>
        {{ form.cooldown_months }}
      </div>

      <div class="col-md-3">
        <label for="{{ form.min_referrals_required.id_for_label }}" class="form-label">
          Minimum de parrainages requis
        </label>
        {{ form.min_referrals_required }}
        <div class="form-text">0 = aucun minimum.</div>
      </div>
    </div>

    <div class="d-flex justify-content-end gap-2 mt-3">
      <a href="{% url 'rewards:list' %}" class="btn btn-outline-secondary">Annuler</a>
      <button type="submit" class="btn btn-primary">Enregistrer</button>
    </div>
  </form>
</div>
{% endblock %}
===== ./templates/rewards/wheels.html =====
{# templates/rewards/wheels.html #}
{% extends "base_dashboard.html" %}
{% block title %}Roue de probabilités • ParrainApp{% endblock %}
{% block body_data_page %}recompenses{% endblock %}

{% block content %}

{# Mini override pour “orange” Bootstrap (Rare) #}
<style>
  .text-bg-orange{color:#fff!important;background-color:#fd7e14!important}
  .bg-orange-subtle{background-color:rgba(253,126,20,.15)!important}
</style>

<header class="mb-4">
  <h1 class="h4 section-title mb-1">Roue de probabilités</h1>
  <div class="text-secondary">Exactement 80/100, 19/100, 1/100 et 1/10000 par entreprise.</div>
</header>

<div class="d-flex justify-content-end mb-3">
  {# même placement que “Ajouter une récompense” dans ta maquette #}
  <form method="post" action="{% url 'rewards:wheel_rebuild' base_key %}" class="me-2">
    {% csrf_token %}
    <button class="btn btn-outline-primary">Régénérer base (100)</button>
  </form>
  <form method="post" action="{% url 'rewards:wheel_rebuild' vr_key %}">
    {% csrf_token %}
    <button class="btn btn-outline-danger">Régénérer très rare (10 000)</button>
  </form>
</div>

<div class="row g-3">
  {# On reprend exactement la grille de 4 cards #}
  {% for c in cards %}
  <div class="col-md-6 col-xl-3">
    <div class="card h-100 shadow-sm">
      <div class="card-header d-flex justify-content-between
           {% if c.code == 'souvent' %}bg-success-subtle
           {% elif c.code == 'moyen' %}bg-warning-subtle
           {% elif c.code == 'rare' %}bg-orange-subtle
           {% else %}bg-danger-subtle
           {% endif %}">
        <span class="badge {{ c.badge_cl }}">{{ c.title }}</span>
        <small class="text-secondary">{{ c.approx }}</small>
      </div>
      <div class="card-body d-flex flex-column">
        <h3 class="h6">{{ c.title }} — restants dans le cycle : {{ c.remaining }} / {{ c.total }}</h3>
        <div class="text-secondary small mb-3">
          Curseur de la roue :
          <strong>{{ c.progress }}%</strong>
        </div>

        <div class="progress mb-3" style="height:6px">
          <div class="progress-bar" style="width: {{ c.progress }}%"></div>
        </div>

        <div class="mt-auto d-flex flex-wrap gap-2">
          {% if c.code in 'souvent,moyen,rare' %}
            <form method="post" action="{% url 'rewards:wheel_reset' base_key %}">
              {% csrf_token %}<button class="btn btn-sm btn-outline-secondary">Remettre à zéro (base)</button>
            </form>
            <form method="post" action="{% url 'rewards:wheel_consume' base_key %}">
              {% csrf_token %}<button class="btn btn-sm btn-outline-primary">Consommer 1 tirage (test)</button>
            </form>
          {% else %}
            <form method="post" action="{% url 'rewards:wheel_reset' vr_key %}">
              {% csrf_token %}<button class="btn btn-sm btn-outline-secondary">Remettre à zéro (très rare)</button>
            </form>
            <form method="post" action="{% url 'rewards:wheel_consume' vr_key %}">
              {% csrf_token %}<button class="btn btn-sm btn-outline-primary">Consommer 1 tirage (test)</button>
            </form>
          {% endif %}
        </div>
      </div>
    </div>
  </div>
  {% endfor %}
</div>

{% endblock %}
===== ./templates/rewards/spin.html =====
{% extends "base_dashboard.html" %}
{% block title %}Roulette de récompense • ParrainApp{% endblock %}
{% block body_data_page %}recompenses{% endblock %}

{% block content %}
<style>
/* --------- Variables de teinte ---------- */
.wheel {
  --accent: #6c757d; /* fallback */
  width: 300px; height: 300px;
  border-radius: 50%;
  border: 8px solid var(--accent);
  position: relative;
  margin: 0 auto;
  box-shadow:
    0 0 0 4px rgba(0,0,0,.03),
    0 0 30px rgba(0,0,0,.06) inset;
  transition: box-shadow .3s ease, border-color .3s ease;
}
.wheel.is-spinning { box-shadow: 0 0 0 4px rgba(0,0,0,.03), 0 0 46px var(--accent); }

/* Aiguille (triangle en haut) */
.wheel::after{
  content:"";
  position:absolute; top:-20px; left:50%; transform:translateX(-50%);
  width:0; height:0;
  border-left: 12px solid transparent;
  border-right:12px solid transparent;
  border-bottom:22px solid var(--accent);
  filter: drop-shadow(0 2px 0 rgba(0,0,0,.15));
}

/* Disque interne : conic-gradient 4 segments dans l’ordre SOUVENT/MOYEN/RARE/TRES_RARE */
.wheel__disk{
  position:absolute; inset: 16px;
  border-radius:50%;
  background:
    conic-gradient(
      rgba(25,135,84,.90) 0deg,   rgba(25,135,84,.90) 90deg,   /* success  -> SOUVENT */
      rgba(13,202,240,.90) 90deg, rgba(13,202,240,.90) 180deg, /* info     -> MOYEN   */
      rgba(253,126,20,.92) 180deg,rgba(253,126,20,.92) 270deg, /* orange   -> RARE    */
      rgba(220,53,69,.92) 270deg, rgba(220,53,69,.92) 360deg   /* danger   -> TRES_RARE */
    );
  transform-origin:50% 50%;
}

/* Animation de rotation */
.spin-anim { transition: transform 2.2s cubic-bezier(.17,.67,.13,1.02); }

/* Map badge -> couleur d’accent */
.wheel--success { --accent:#198754; } /* vert   */
.wheel--info    { --accent:#0dcaf0; } /* bleu   */
.wheel--warning { --accent:#fd7e14; } /* orange */
.wheel--danger  { --accent:#dc3545; } /* rouge  */

/* Carte résultat */
.result-card { border-left: 4px solid var(--accent); }
</style>

<header class="mb-4 d-flex justify-content-between align-items-center">
  <div>
    <h1 class="h5 mb-1">Animation de la roue</h1>
    <div class="text-secondary">
      Récompense attribuée à <strong>{{ reward.client.last_name }} {{ reward.client.first_name }}</strong>
    </div>
  </div>
  <a class="btn btn-outline-secondary" href="{% url 'dashboard:client_detail' pk=reward.client_id %}">Retour fiche client</a>
</header>

<div class="card shadow-sm">
  <div class="card-body d-flex flex-column align-items-center">
    {# La classe wheel--{{ ui.badge }} pose la bonne couleur (success/info/warning/danger) #}
    <div class="wheel wheel--{{ ui.badge }} is-spinning">
      <div id="disk" class="wheel__disk spin-anim"></div>
    </div>

    <div class="mt-4 text-center result-card px-3 py-2 rounded">
      <span class="badge text-bg-{{ ui.badge }} me-2">{{ ui.label }}</span>
      <strong id="rewardLabel">{{ reward.label }}</strong>
    </div>
  </div>
</div>

<script>
(function(){
  const disk = document.getElementById('disk');
  const target = {{ target_angle|default:1440 }};
  // Lance la rotation après un mini délai pour laisser le layout se peindre
  setTimeout(()=>{ disk.style.transform = `rotate(${target}deg)`; }, 60);
  // Retire l'état “is-spinning” une fois l’animation finie (effet de lueur)
  disk.addEventListener('transitionend', () => {
    const wheel = disk.closest('.wheel');
    wheel && wheel.classList.remove('is-spinning');
  }, { once: true });
})();
</script>
{% endblock %}
===== ./templates/rewards/stats.html =====
{# templates/rewards/stats.html #}
{% extends "base_dashboard.html" %}
{% load static %}
{% block title %}Statistiques • Récompenses{% endblock %}
{% block body_data_page %}stats{% endblock %}
{% block nav_rewards_active %}active{% endblock %}

{% block content %}
<header class="mb-4">
  {% if company %}
    <h1 class="h4 section-title mb-1">Statistiques — {{ company.name }}</h1>
    <div class="text-secondary">Vue des récompenses pour cette entreprise.</div>
  {% elif is_superadmin %}
    <h1 class="h4 section-title mb-1">Statistiques — Global (Superadmin)</h1>
    <div class="text-secondary">Vue d’ensemble sur l’ensemble des entreprises.</div>
  {% else %}
    <h1 class="h4 section-title mb-1">Statistiques</h1>
  {% endif %}
</header>

{# ===== KPI globaux (uniquement si global_kpi est fourni) ===== #}
{% if global_kpi %}
<div class="row g-3 mb-3">
  <div class="col-12 col-md-6 col-xl-3">
    <div class="card h-100 shadow-sm"><div class="card-body">
      <div class="text-secondary small">Parrainages (mois)</div>
      <div class="stat-num">{{ global_kpi.referrals_month|default:0 }}</div>
    </div></div>
  </div>
  <div class="col-12 col-md-6 col-xl-3">
    <div class="card h-100 shadow-sm"><div class="card-body">
      <div class="text-secondary small">Cadeaux distribués</div>
      <div class="stat-num">{{ global_kpi.rewards_sent|default:0 }}</div>
    </div></div>
  </div>
  <div class="col-12 col-md-6 col-xl-3">
    <div class="card h-100 shadow-sm"><div class="card-body">
      <div class="text-secondary small">Cadeaux en attente</div>
      <div class="stat-num">{{ global_kpi.rewards_pending|default:0 }}</div>
    </div></div>
  </div>
  <div class="col-12 col-md-6 col-xl-3">
    <div class="card h-100 shadow-sm"><div class="card-body">
      <div class="text-secondary small">Base clients</div>
      <div class="stat-num">{{ global_kpi.clients|default:0 }}</div>
    </div></div>
  </div>
</div>
{% endif %}

{# ===== 2 visuels communs (mensuel + top cadeaux) ===== #}
<div class="row g-3 mb-3">
  <div class="col-lg-7">
    <div class="card h-100 shadow-sm">
      <div class="card-header d-flex justify-content-between align-items-center">
        <div class="fw-semibold">Récompenses créées — 4 derniers mois</div>
        <small class="text-secondary">Volume par mois</small>
      </div>
      <div class="card-body">
        {% if monthly_rows %}
          <ul class="list-group list-group-flush">
            {% for r in monthly_rows %}
            <li class="list-group-item">
              <div class="d-flex justify-content-between mb-1">
                <span class="small text-secondary">{{ r.month|date:"M Y" }}</span>
                <span class="small">{{ r.n }}</span>
              </div>
              <div class="progress" role="progressbar" aria-valuenow="{{ r.pct }}" aria-valuemin="0" aria-valuemax="100">
                <div class="progress-bar" style="width: {{ r.pct }}%"></div>
              </div>
            </li>
            {% endfor %}
          </ul>
        {% else %}
          <div class="text-secondary">Pas encore de données.</div>
        {% endif %}
      </div>
    </div>
  </div>

  <div class="col-lg-5">
    <div class="card h-100 shadow-sm">
      <div class="card-header d-flex justify-content-between align-items-center">
        <div class="fw-semibold">Top cadeaux</div>
        <small class="text-secondary">Part en %</small>
      </div>
      <div class="card-body">
        {% if top_gifts %}
          <ul class="list-group list-group-flush">
            {% for g in top_gifts %}
            <li class="list-group-item">
              <div class="d-flex justify-content-between mb-1">
                <span class="small">{{ g.label }}</span>
                <span class="small">{{ g.n }} — {{ g.pct }}%</span>
              </div>
              <div class="progress" role="progressbar" aria-valuenow="{{ g.pct }}" aria-valuemin="0" aria-valuemax="100">
                <div class="progress-bar" style="width: {{ g.pct }}%"></div>
              </div>
            </li>
            {% endfor %}
          </ul>
        {% else %}
          <div class="text-secondary">Pas de cadeaux enregistrés.</div>
        {% endif %}
      </div>
    </div>
  </div>
</div>

{# ===== Détail par entreprise (uniquement en mode global Superadmin) ===== #}
{% comment %} {% if global_rows %}
<div class="card shadow-sm">
  <div class="card-header d-flex justify-content-between align-items-center">
    <div class="fw-semibold">Détail par entreprise</div>
    <small class="text-secondary">Parrainages du mois, cadeaux et base clients</small>
  </div>
  <div class="card-body p-0">
    <div class="table-responsive">
      <table class="table align-middle mb-0">
        <thead class="table-light">
          <tr>
            <th>Entreprise</th>
            <th class="text-end">Parrainages (mois)</th>
            <th class="text-end">Cadeaux distribués</th>
            <th class="text-end">Cadeaux en attente</th>
            <th class="text-end">Base clients</th>
            <th class="text-end">Actions</th>
          </tr>
        </thead>
        <tbody>
          {% for r in global_rows %}
          <tr>
            <td class="fw-semibold">{{ r.company.name }}</td>
            <td class="text-end">{{ r.referrals_month }}</td>
            <td class="text-end"><span class="badge text-bg-success">{{ r.rewards_sent }}</span></td>
            <td class="text-end"><span class="badge text-bg-warning">{{ r.rewards_pending }}</span></td>
            <td class="text-end">{{ r.clients }}</td>
            <td class="text-end">
              <div class="d-inline-flex flex-wrap gap-2">
                <a class="btn btn-sm btn-outline-primary"
                   href="{% url 'dashboard:company_home' %}?company={{ r.company.id }}">Tableau</a>
                <a class="btn btn-sm btn-outline-secondary"
                   href="{% url 'rewards:history_company' %}?company={{ r.company.id }}">Historique</a>
                <a class="btn btn-sm btn-outline-dark"
                   href="{% url 'rewards:stats' %}?company={{ r.company.id }}">Stats</a>
              </div>
            </td>
          </tr>
          {% empty %}
          <tr><td colspan="6" class="text-secondary p-3">Aucune entreprise.</td></tr>
          {% endfor %}
        </tbody>
      </table>
    </div>
  </div>
</div>
{% endif %} {% endcomment %}
{% endblock %}
===== ./templates/rewards/use_reward.html =====
{% load static %}
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{{ company_name|default:"Récompense" }}</title>
  <style>
    :root{
      --g1:#ff4d6d; --g2:#7b2cbf;
      --ink:#1e164b; --muted:#6b6b8a; --surface:#ffffff;
      --shadow: 0 10px 30px rgba(24,17,62,.15);
      --radius: 22px;
      --brand: var(--c1, #6c5ce7);
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:#f7f8fb;color:#1a1537;font-family: ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
    .hero{
      background:
        radial-gradient(1200px 400px at 10% -10%, rgba(255,255,255,.2), transparent),
        linear-gradient(135deg,var(--g1),var(--g2));
      color:#fff; text-align:center; padding:56px 16px 72px;
    }
    .hero h1{margin:0 0 8px; font-weight:900; letter-spacing:.3px; font-size: clamp(26px, 4.2vw, 48px);}
    .hero p{margin:0; opacity:.95; font-size: clamp(14px, 2.2vw, 20px);}

    /* Carte principale */
    .card{
      width:min(760px, calc(100% - 24px));
      margin:-40px auto 40px; background:var(--surface); border-radius:var(--radius);
      box-shadow:var(--shadow); overflow:hidden;
    }

    /* Head badges — mobile-first */
    .card-head{
      display:flex; align-items:center; justify-content:space-between;
      gap:.75rem; padding:18px 22px;
      background: linear-gradient(135deg, rgba(255,255,255,.6), rgba(255,255,255,.35));
      backdrop-filter: blur(6px);
    }
    .badge{
      display:inline-flex; align-items:center; gap:.5rem;
      border-radius:999px; padding:.5rem .9rem;
      font-weight:700; line-height:1; white-space:nowrap;
      box-shadow:0 6px 14px rgba(12,16,32,.12);
      border:1px solid transparent;
      max-width:100%;
      font-size:13px;
    }
    .chip-primary{
      background:#0b1020; color:#fff; border-color:#0b1020;
      box-shadow:0 6px 16px rgba(11,16,32,.28), 0 0 0 2px color-mix(in oklab, var(--brand) 25%, #ffffff);
    }
    .chip-emoji{ font-size:1.05em; }
    .chip-text{
      display:inline-block; overflow:hidden; text-overflow:ellipsis;
      max-width: min(78vw, 520px);
      font-size: clamp(12px, 3.4vw, 14px);
    }
    .badge-sec{ background:#eef2f7; color:#111827; font-weight:600; border-color:#e6ebf1; }
    .chip-secure::before{ content:"🔒"; margin-right:.35rem; }

    .card-body{padding:22px;}
    h2{margin:6px 0 14px; font-size:32px; letter-spacing:.2px}
    .muted{color:var(--muted); font-size:14px;}

    .panel{
      border:1px dashed #e5e6ef; padding:16px; border-radius:14px; background:#fbfbfe; color:#2a2942;
    }
    .row{display:flex; gap:14px; flex-wrap:wrap; margin-top:14px}
    .row > *{flex:1 1 220px}

    /* Lien à copier : FIX mobile */
    .codebox{
      display:flex; align-items:center; gap:10px;
      border:1px solid #ececf6; padding:12px 14px; border-radius:12px; background:#fff;
      width:100%; overflow:hidden;
    }
    .codebox .url{
      flex:1 1 0;                 /* ← prend tout l'espace dispo */
      min-width:0;                /* ← autorise l’ellipsis */
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .codebox .btn{
      flex:0 0 auto;              /* ← le bouton ne se compresse pas */
    }

    .btn{
      appearance:none; border:0; border-radius:12px; padding:12px 16px; font-weight:700; cursor:pointer;
      background:#0f1226; color:#fff; box-shadow:0 6px 16px rgba(15,18,38,.18);
    }
    .btn.secondary{background:#eef0f6; color:#1e1a3a; box-shadow:none;}
    .footer{ text-align:center; color:#8b8aa7; font-size:14px; padding-bottom:32px;}
    .link{color:#5843e3; text-decoration:none; font-weight:700}

    /* Responsive chips */
    @media (max-width: 480px){
      .card-head{ flex-wrap:wrap; }
      .chip-primary{ flex:1 1 100%; justify-content:center; padding:.65rem 1rem; }
      .badge-sec{ margin-left:auto; padding:.5rem .75rem; }
      .btn{ padding:12px 14px; }
    }
    @media (max-width: 360px){
      .chip-text{ max-width: 72vw; }
      .badge-sec{ font-size:.92rem; }
      .btn{ padding:10px 12px; font-size:13px; }
    }

    /* Dark mode */
    @media (prefers-color-scheme: dark){
      body{background:#0e0f17; color:#e9e8f3}
      .hero{color:#fff}
      .card{background:#131527}
      .card-head{background:rgba(255,255,255,.05)}
      .panel{background:#0f1020; border-color:#262842}
      .codebox{background:#0f1020; border-color:#262842}
      .btn.secondary{background:#1b1d37; color:#fff}
      .footer{color:#a7a6c2}
      .badge-sec{ background:#1b2130; color:#e8ecf6; border-color:#263146; }
    }
  </style>
</head>
<body>

  <section class="hero">
    <div style="font-size:28px; line-height:1">🎉</div>
    <h1>{{ headline }}</h1>
    {% if celebrate %}<p>{{ celebrate }}</p>{% endif %}
    {% if subline %}<p style="margin-top:8px; opacity:.85">{{ subline }}</p>{% endif %}
  </section>

  <!-- Carte -->
  <main class="card" role="main" aria-labelledby="gift-title">

    <!-- HEAD DESKTOP + MOBILE -->
    <div class="card-head" role="group" aria-label="statut du parrainage">
      <div class="badge chip-primary">
        <span class="chip-emoji" aria-hidden="true">🎁</span>
        <span class="chip-text">{{ ribbon|default:"Ton cadeau" }}</span>
      </div>
      <div class="badge badge-sec chip-secure">Lien sécurisé</div>
    </div>

    <div class="card-body">
      <div class="muted" style="margin-bottom:6px">{{ company_name }}</div>
      <h2 id="gift-title">{{ reward.label }}</h2>

      {% if reward.valid_until %}
        <div class="muted" style="margin:8px 0 16px">
          Date limite d’utilisation :
          {{ reward.valid_until|date:"d F Y" }}
        </div>
      {% endif %}

      <div class="panel">
        Présentez <strong>ce lien</strong> en caisse. Un membre de l’équipe validera la récompense.
        <div class="row">
          <div>
            <div class="muted" style="margin:10px 0 6px">Ton lien</div>
            <div class="codebox" id="copybox">
              <span class="url">{{ claim_absolute }}</span>
              <button class="btn" id="copyBtn" data-url="{{ claim_absolute }}">Copier le lien</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <div class="footer">
    Merci pour la recommandation ❤️ — {{ company_name|default:"" }}
  </div>

  <script>
    (function(){
      const btn = document.getElementById('copyBtn');
      if(!btn) return;
      btn.addEventListener('click', async function(){
        try{
          const url = btn.getAttribute('data-url') || location.href;
          await navigator.clipboard.writeText(url);
          btn.textContent = "Copié !";
          setTimeout(()=> btn.textContent = "Copier le lien", 1600);
        }catch(e){
          alert("Lien: " + (btn.getAttribute('data-url') || location.href));
        }
      });
    })();
  </script>
</body>
</html>
===== ./templates/rewards/test_wheel.html =====
{% extends "base_dashboard.html" %}
{% block title %}Roue de test • Chuchote{% endblock %}
{% block body_data_page %}recompenses{% endblock %}

{% block content %}
<style>
.wheel { --accent:#6c757d; width:300px; height:300px; border-radius:50%;
  border:8px solid var(--accent); position:relative; margin:0 auto;
  box-shadow:0 0 0 4px rgba(0,0,0,.03), 0 0 30px rgba(0,0,0,.06) inset;
  transition: box-shadow .3s ease, border-color .3s ease;
}
.wheel.is-spinning { box-shadow:0 0 0 4px rgba(0,0,0,.03), 0 0 46px var(--accent); }
.wheel::after{ content:""; position:absolute; top:-20px; left:50%; transform:translateX(-50%);
  width:0; height:0; border-left:12px solid transparent; border-right:12px solid transparent;
  border-bottom:22px solid var(--accent); filter: drop-shadow(0 2px 0 rgba(0,0,0,.15));
}
.wheel__disk{ position:absolute; inset:16px; border-radius:50%;
  background: conic-gradient(
    rgba(25,135,84,.90) 0deg,   rgba(25,135,84,.90) 90deg,
    rgba(13,202,240,.90) 90deg, rgba(13,202,240,.90) 180deg,
    rgba(253,126,20,.92) 180deg,rgba(253,126,20,.92) 270deg,
    rgba(220,53,69,.92) 270deg, rgba(220,53,69,.92) 360deg
  );
  transform-origin:50% 50%;
}
.spin-anim { transition: transform 2.2s cubic-bezier(.17,.67,.13,1.02); }
.wheel--success { --accent:#198754; }  /* SOUVENT */
.wheel--info    { --accent:#0dcaf0; }  /* MOYEN   */
.wheel--warning { --accent:#fd7e14; }  /* RARE    */
.wheel--danger  { --accent:#dc3545; }  /* TRES_RARE */
.wheel--secondary { --accent:#6c757d; } /* NO_HIT  */
.result-card { border-left:4px solid var(--accent); }
</style>

<header class="mb-4 d-flex justify-content-between align-items-center">
  <div>
    <h1 class="h5 mb-1">Roue de test (aléatoire, sans attribution)</h1>
    <div class="text-secondary">Tire au sort un bucket selon la distribution choisie.</div>
  </div>
  <a class="btn btn-outline-secondary" href="{% url 'rewards:list' %}">← Récompenses</a>
</header>

<form class="card mb-3" method="get">
  <div class="card-body row g-2 align-items-end">
    <div class="col-sm-4">
      <label class="form-label">Mode</label>
      <select name="mode" class="form-select">
        <option value="combined" {% if mode == 'combined' %}selected{% endif %}>Combiné (1/100000 très rare + base 980/19/1)</option>
        <option value="base" {% if mode == 'base' %}selected{% endif %}>Base (SOUVENT/MOYEN/RARE)</option>
        <option value="very_rare" {% if mode == 'very_rare' %}selected{% endif %}>Très rare uniquement</option>
      </select>
    </div>
    <div class="col-sm-3">
      <label class="form-label">Seed (optionnel)</label>
      <input type="text" class="form-control" name="seed" value="{{ seed }}">
    </div>
    <div class="col-sm-3">
      <label class="form-label">Simuler N tirages (optionnel)</label>
      <input type="number" class="form-control" name="n" value="{{ simulate_n|default:0 }}" min="0" step="1">
    </div>
    <div class="col-sm-2 d-flex gap-2">
      <button class="btn btn-primary w-100" type="submit">Tirer</button>
      <a class="btn btn-outline-secondary" href="{% url 'rewards:test_wheel' %}">Reset</a>
    </div>
  </div>
</form>

<div class="card shadow-sm mb-3">
  <div class="card-body d-flex flex-column align-items-center">
    <div class="wheel wheel--{{ ui.badge }} is-spinning">
      <div id="disk" class="wheel__disk spin-anim"></div>
    </div>
    <div class="mt-4 text-center result-card px-3 py-2 rounded">
      <span class="badge text-bg-{{ ui.badge }} me-2">
        {% if bucket == 'NO_HIT' %}Aucun gain{% else %}{{ ui.label }}{% endif %}
      </span>
      <strong id="rewardLabel">
        {% if bucket == 'SOUVENT' %}-10 %{% elif bucket == 'MOYEN' %}-20 %{% elif bucket == 'RARE' %}Cadeau rare{% elif bucket == 'TRES_RARE' %}Jackpot !{% else %}—{% endif %}
      </strong>
    </div>
  </div>
</div>

{% if counts %}
<div class="card">
  <div class="card-header">Simulation ({{ simulate_n }} tirages)</div>
  <div class="card-body">
    <div class="table-responsive">
      <table class="table table-sm align-middle">
        <thead>
          <tr><th>Bucket</th><th>Occurences</th><th>% observé</th></tr>
        </thead>
        <tbody>
          {% for k,v in counts.items %}
          <tr>
            <td>{{ k }}</td>
            <td>{{ v }}</td>
            <td>{{ pct|get_item:k|default:"0" }} %</td>
          </tr>
          {% endfor %}
        </tbody>
      </table>
    </div>
    <div class="text-secondary small">
      Combiné attendu (théorique) : TRES_RARE ≈ 0.001 %, sinon base 980/1000, 19/1000, 1/1000.
    </div>
  </div>
</div>
{% endif %}

<script>
(function(){
  const disk = document.getElementById('disk');
  const target = {{ target_angle|default:1440 }};
  setTimeout(()=>{ disk.style.transform = `rotate(${target}deg)`; }, 60);
  disk.addEventListener('transitionend', () => {
    const wheel = disk.closest('.wheel');
    wheel && wheel.classList.remove('is-spinning');
  }, { once: true });
})();
</script>
{% endblock %}
===== ./templates/rewards/list.html =====
{# templates/rewards/list.html #}
{% extends "base_dashboard.html" %}
{% block title %}Récompenses • ParrainApp{% endblock %}
{% block body_data_page %}recompenses{% endblock %}

{% block content %}
<header class="mb-4">
  <h1 class="h4 section-title mb-1">Récompenses</h1>
  <div class="text-secondary">Définissez les cadeaux (nom) et le délai. Les probabilités sont fixes.</div>
</header>

{% if not items %}
  <div class="card shadow-sm"><div class="card-body text-secondary">Aucune récompense.</div></div>
{% else %}
  <div class="row g-3">
    {% for r, ui in items %}
      <div class="col-md-6 col-xl-3">
        <div class="card h-100 shadow-sm">
          <div class="card-header bg-{{ ui.badge }}-subtle d-flex justify-content-between">
            <span class="badge text-bg-{{ ui.badge }}">
              {% if ui.label == "Moyen" %}Moyen{% else %}{{ ui.label }}{% endif %}
            </span>
            <small class="text-secondary">~{{ r.probability_display }}</small>
          </div>
          <div class="card-body d-flex flex-column">
            <h3 class="h6">{{ r.label }}</h3>

            <div class="text-secondary small">
              Délai : {{ r.cooldown_months }} mois
            </div>
            <div class="text-secondary small mb-3">
              Minimum requis : {{ r.min_referrals_required }} parrainage{{ r.min_referrals_required|pluralize }}
            </div>

            <div class="mt-auto d-flex gap-2">
              <a class="btn btn-sm btn-outline-primary" href="{% url 'rewards:update' r.pk %}">Modifier</a>
            </div>
          </div>
        </div>
      </div>
    {% endfor %}
  </div>
{% endif %}
{# Données probabilistes — mêmes constantes que Reward #}
{{ TEST_WHEEL|json_script:"wt-data" }}

<style>
#wheel-test .wheel{
  --accent:#6c757d;
  width:300px;height:300px;border-radius:50%;
  border:8px solid var(--accent);position:relative;margin:0 auto;
  box-shadow:0 0 0 4px rgba(0,0,0,.03), inset 0 0 30px rgba(0,0,0,.06);
  transition: box-shadow .3s ease, border-color .3s ease;
}
#wheel-test .wheel.is-spinning{ box-shadow:0 0 0 4px rgba(0,0,0,.03), 0 0 46px var(--accent); }

#wheel-test .needle{
  position:absolute; top:-20px; left:50%; transform:translateX(-50%);
  width:0;height:0;border-left:12px solid transparent;border-right:12px solid transparent;
  border-bottom:22px solid var(--accent); filter: drop-shadow(0 2px 0 rgba(0,0,0,.15));
}

/* 4 segments visuels (égaux) pour une belle animation ; le tirage, lui, respecte les vraies probas */
#wheel-test .wheel__disk{
  position:absolute; inset:16px; border-radius:50%;
  background: conic-gradient(
    rgba(25,135,84,.90) 0deg,   rgba(25,135,84,.90) 90deg,   /* SOUVENT  */
    rgba(13,202,240,.90) 90deg, rgba(13,202,240,.90) 180deg, /* MOYEN    */
    rgba(253,126,20,.92) 180deg,rgba(253,126,20,.92) 270deg, /* RARE     */
    rgba(220,53,69,.92) 270deg, rgba(220,53,69,.92) 360deg   /* TRES_RARE */
  );
  transform-origin:50% 50%;
}
#wheel-test .spin-anim{ transition: transform 2.2s cubic-bezier(.17,.67,.13,1.02); }

#wheel-test .wheel--success { --accent:#198754; }
#wheel-test .wheel--info    { --accent:#0dcaf0; }
#wheel-test .wheel--warning { --accent:#fd7e14; }
#wheel-test .wheel--danger  { --accent:#dc3545; }
#wheel-test .wheel--secondary{ --accent:#6c757d; }

#wheel-test .result-card{ border-left:4px solid var(--accent); }
</style>

<section id="wheel-test" class="mt-4">
  <div class="card mb-3">
    <div class="card-header d-flex justify-content-between align-items-center">
      <span>🎡 Roue de test (aléatoire, sans attribution)</span>
      <span class="text-secondary small">Utilise les mêmes probas que Reward (1/100000 très rare + 980/19/1)</span>
    </div>
    <div class="card-body">
      <form class="row g-2 align-items-end" onsubmit="return false;">
        <div class="col-md-3">
          <label class="form-label">Simuler N tirages (optionnel)</label>
          <input id="wt-n" type="number" class="form-control" min="0" step="1" value="0">
        </div>
        <div class="col-md-3">
          <label class="form-label">Seed (optionnel)</label>
          <input id="wt-seed" type="text" class="form-control" placeholder="ex: 42">
        </div>
        <div class="col-md-6 d-flex gap-2">
          <button id="wt-draw" class="btn btn-primary" type="button">Tirer</button>
          <button id="wt-reset" class="btn btn-outline-secondary" type="button">Reset</button>
        </div>
      </form>

      <div class="mt-4 d-flex flex-column align-items-center">
        <div id="wt-wheel" class="wheel wheel--secondary">
          <div class="needle" aria-hidden="true"></div>
          <div id="wt-disk" class="wheel__disk spin-anim"></div>
        </div>

        <div id="wt-result" class="mt-4 text-center result-card px-3 py-2 rounded">
          <span id="wt-badge" class="badge text-bg-secondary me-2">—</span>
          <strong id="wt-label">—</strong>
        </div>
      </div>

      <div id="wt-sim" class="table-responsive mt-4 d-none">
        <table class="table table-sm align-middle mb-0">
          <thead><tr><th>Bucket</th><th>Occurences</th><th>% observé</th></tr></thead>
          <tbody id="wt-rows"></tbody>
        </table>
      </div>
    </div>
  </div>
</section>

<script>
(function(){
  // --- Ordre d’affichage & UI (inchangé) ---
  const ORDER = ["SOUVENT","MOYEN","RARE","TRES_RARE"];
  const UI = {
    SOUVENT:   { badge: "success",  label: "Souvent",   text: "-10 %" },
    MOYEN:     { badge: "info",     label: "Moyen",     text: "-20 %" },
    RARE:      { badge: "warning",  label: "Rare",      text: "Cadeau rare" },
    TRES_RARE: { badge: "danger",   label: "Très rare", text: "Jackpot !" },
  };

  // ---- RNG seedable (xorshift32) — on garde tel quel ----
  function hashSeed(s){ let h=2166136261>>>0; for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,16777619);} return h>>>0; }
  function rngFromSeed(seedStr){
    if (!seedStr) return Math.random;
    let x = (typeof seedStr==="number"?seedStr:hashSeed(String(seedStr))) || 1;
    return function(){ x^=x<<13; x^=x>>>17; x^=x<<5; x>>>=0; return x/4294967296; };
  }

  // ---- Probabilités demandées (brutes) ----
  // SOUVENT=80/100, MOYEN=19/100, RARE=0.99999/100, TRES_RARE=1/100000
  const RAW = {
    SOUVENT:   80/100,
    MOYEN:     19/100,
    RARE:      0.99999/100,
    TRES_RARE: 1/100000
  };

  // Normalisation pour que la somme = 1 exactement
  const MASS = Object.values(RAW).reduce((a,b)=>a+b,0);
  const W = Object.fromEntries(ORDER.map(k => [k, RAW[k] / MASS]));

  // ---- Tirage cumulatif sur les poids normalisés (une seule passe) ----
  function drawOnce(rnd){
    const x = rnd();
    let acc = 0;
    for (const k of ORDER){
      acc += W[k];
      if (x < acc) return k;
    }
    return ORDER[ORDER.length-1]; // sauvegarde (jamais atteinte en pratique)
  }

  // ---- UI helpers (inchangés) ----
  const $ = (id)=>document.getElementById(id);
  const disk  = $("wt-disk");
  const wheel = $("wt-wheel");
  const badge = $("wt-badge");
  const label = $("wt-label");
  const rows  = $("wt-rows");
  const simBox= $("wt-sim");

  function animateTo(bucket){
    const ui = UI[bucket];
    wheel.className = "wheel wheel--" + ui.badge + " is-spinning";
    badge.className = "badge text-bg-" + ui.badge + " me-2";
    badge.textContent = ui.label;
    label.textContent = ui.text;

    const segment = 360 / ORDER.length;
    const idx = Math.max(0, ORDER.indexOf(bucket));
    const target = 4*360 + Math.floor(idx * segment + segment/2);
    requestAnimationFrame(()=>{ disk.style.transform = `rotate(${target}deg)`; });
    disk.addEventListener("transitionend", ()=> wheel.classList.remove("is-spinning"), {once:true});
  }

  function simulate(n, rnd){
    const buckets = ORDER.slice();
    const counts = Object.fromEntries(buckets.map(b=>[b,0]));
    for (let i=0;i<n;i++) counts[drawOnce(rnd)]++;
    const tot = buckets.reduce((a,b)=>a+counts[b],0)||1;
    rows.innerHTML = "";
    buckets.forEach(k=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${k}</td><td>${counts[k]}</td><td>${(counts[k]*100/tot).toFixed(2)} %</td>`;
      rows.appendChild(tr);
    });
    simBox.classList.toggle("d-none", n<=0);
  }

  // ---- Évènements (inchangés) ----
  $("wt-draw").addEventListener("click", ()=>{
    const N   = parseInt($("wt-n").value||"0",10);
    const seed= $("wt-seed").value;
    const rnd = rngFromSeed(seed);
    const b = drawOnce(rnd);
    animateTo(b);
    if (N>0) simulate(N, rngFromSeed(seed));
  });

  $("wt-reset").addEventListener("click", ()=>{
    $("wt-n").value = 0; $("wt-seed").value = "";
    simBox.classList.add("d-none"); rows.innerHTML = "";
    wheel.className = "wheel wheel--secondary";
    badge.className = "badge text-bg-secondary me-2";
    badge.textContent = "—"; label.textContent = "—";
    disk.style.transform = "rotate(0deg)";
  });
})();
</script>


{% endblock %}
===== ./templates/rewards/history.html =====
{# templates/rewards/history.html #}
{% extends "base_dashboard.html" %}
{% load dict_extras %}

{% block title %}Historique des récompenses • {{ company.name }}{% endblock %}
{% block body_data_page %}recompenses{% endblock %}

{% block content %}
<header class="mb-4">
  <h1 class="h4 section-title mb-2">Historique des récompenses — {{ company.name }}</h1>
  <div class="text-secondary">Toutes les récompenses de l’entreprise, tous clients confondus.</div>
</header>

<div class="card shadow-sm mb-3">
  <div class="card-body">
    <form method="get" class="row g-2 align-items-end">
      {# ✅ très important pour le Superadmin : conserver l’entreprise ciblée #}
      {% if company and company.id %}
        <input type="hidden" name="company" value="{{ company.id }}">
      {% endif %}

      <div class="col-lg-4">
        <label class="form-label mb-1">Recherche</label>
        <input type="text" name="q" value="{{ q }}" class="form-control"
               placeholder="Client (nom/prénom/email) ou libellé de récompense…">
      </div>

      <div class="col-lg-3">
        <label class="form-label mb-1">État</label>
        <select name="state" class="form-select">
          <option value="">— Tous —</option>
          {% for k, lbl in states %}
            <option value="{{ k }}" {% if k == state %}selected{% endif %}>{{ lbl }}</option>
          {% endfor %}
        </select>
      </div>

      <div class="col-lg-3">
        <label class="form-label mb-1">Type</label>
        <select name="bucket" class="form-select">
          <option value="">— Tous —</option>
          {% for k, lbl in buckets %}
            <option value="{{ k }}" {% if k == bucket %}selected{% endif %}>{{ lbl }}</option>
          {% endfor %}
        </select>
      </div>

      <div class="col-lg-2 d-flex gap-2">
        <button class="btn btn-primary w-100" type="submit">Filtrer</button>
        {# ✅ réinitialiser tout en gardant le contexte company pour superadmin #}
        <a class="btn btn-outline-secondary"
           href="{% url 'rewards:history_company' %}{% if company and company.id %}?company={{ company.id }}{% endif %}">
          Réinitialiser
        </a>
      </div>
    </form>
  </div>
</div>

{% if page and page.object_list %}
  <div class="card shadow-sm">
    <div class="table-responsive">
      <table class="table align-middle mb-0">
        <thead class="table-light">
          <tr>
            <th style="width: 140px;">Date</th>
            <th>Client</th>
            <th style="width: 110px;">Rôle</th>
            <th>Récompense</th>
            <th style="width: 130px;">Type</th>
            <th style="width: 130px;">État</th>
          </tr>
        </thead>
        <tbody>
          {% for r in page.object_list %}
            <tr>
              <td>
                <div class="small">{{ r.created_at|date:"d/m/Y" }}</div>
                <div class="text-secondary small">{{ r.created_at|date:"H:i" }}</div>
              </td>

              <td>
                <div class="fw-semibold">
                  <a href="{% url 'dashboard:client_detail' pk=r.client_id %}" class="text-decoration-none">
                    {{ r.client.last_name }} {{ r.client.first_name }}
                  </a>
                </div>
                <div class="text-secondary small">{{ r.client.email|default:"—" }}</div>
              </td>

              <td>
                {% if r.referral_id %}
                  {% if r.client_id == r.referral.referrer_id %}
                    <span class="badge text-bg-info">Parrain</span>
                  {% elif r.client_id == r.referral.referee_id %}
                    <span class="badge text-bg-secondary">Filleul</span>
                  {% else %}
                    <span class="badge text-bg-light text-dark">Autre</span>
                  {% endif %}
                {% else %}
                  <span class="text-secondary small">—</span>
                {% endif %}
              </td>

              <td><div class="fw-semibold">{{ r.label }}</div></td>

              <td>
                {# ✅ lire BUCKET_UI[r.bucket] en utilisant le filtre get_item #}
                {% with ui=BUCKET_UI|get_item:r.bucket %}
                  <span class="badge text-bg-{{ ui.badge|default:'secondary' }}">{{ ui.label|default:r.bucket }}</span>
                {% endwith %}
              </td>

              <td>
                {# ✅ lire STATE_UI[r.state] en utilisant le filtre get_item #}
                {% with st=STATE_UI|get_item:r.state %}
                  <span class="badge text-bg-{{ st.badge|default:'secondary' }}">{{ st.label|default:r.state }}</span>
                {% endwith %}
              </td>
            </tr>
          {% endfor %}
        </tbody>
      </table>
    </div>

    {% if page.paginator.num_pages > 1 %}
      <div class="card-footer bg-transparent d-flex justify-content-end align-items-center gap-2">
        {% if page.has_previous %}
          <a class="btn btn-sm btn-outline-secondary"
             href="?p={{ page.previous_page_number }}&bucket={{ bucket }}&state={{ state }}&q={{ q|urlencode }}{% if company and company.id %}&company={{ company.id }}{% endif %}">
            Préc.
          </a>
        {% endif %}
        <span class="small">Page {{ page.number }}/{{ page.paginator.num_pages }}</span>
        {% if page.has_next %}
          <a class="btn btn-sm btn-outline-secondary"
             href="?p={{ page.next_page_number }}&bucket={{ bucket }}&state={{ state }}&q={{ q|urlencode }}{% if company and company.id %}&company={{ company.id }}{% endif %}">
            Suiv.
          </a>
        {% endif %}
      </div>
    {% endif %}
  </div>
{% else %}
  <div class="card shadow-sm">
    <div class="card-body text-secondary">Aucune récompense trouvée pour ces critères.</div>
  </div>
{% endif %}
{% endblock %}
===== ./templates/rewards/confirm_delete.html =====
{# templates/rewards/confirm_delete.html #}
{% extends "base_dashboard.html" %}
{% block title %}Supprimer la récompense{% endblock %}

{% block content %}
<header class="mb-3">
  <h1 class="h4 section-title mb-1">Supprimer la récompense</h1>
</header>

<div class="card shadow-sm">
  <div class="card-body">
    <p>Supprimer définitivement <strong>{{ reward.label }}</strong> ?</p>
    <form method="post" class="d-flex gap-2">
      {% csrf_token %}
      <button class="btn btn-danger" type="submit">Supprimer</button>
      <a class="btn btn-outline-secondary" href="{% url 'rewards:list' %}">Annuler</a>
    </form>
  </div>
</div>
{% endblock %}
===== ./templates/rewards/use_reward_done.html =====
{% extends "base_dashboard.html" %}
{% block title %}Récompense utilisée{% endblock %}

{% block content %}
<div class="card shadow-sm">
  <div class="card-body text-center">
    <h2 class="h4 mb-3">🎉 Bravo !</h2>
    <p>Vous venez d’utiliser la récompense :</p>
    <h3 class="h5">{{ reward.label }}</h3>
    <p class="text-secondary">Statut : <span class="badge bg-success">Utilisée</span></p>
  </div>
</div>
{% endblock %}

