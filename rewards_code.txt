===== ./rewards/templatetags/ __init__.py =====
===== ./rewards/templatetags/dict_extras.py =====
# core/templatetags/dict_extras.py
from django import template
register = template.Library()

@register.filter
def get_item(d, key):
    try:
        return d.get(key)
    except Exception:
        return None===== ./rewards/signals.py =====
# rewards/signals.py
from django.db.models.signals import pre_save
from django.dispatch import receiver
from .models import Reward

@receiver(pre_save, sender=Reward)
def reward_token_autogen(sender, instance: Reward, **kwargs):
    if not instance.token:
        instance.ensure_token()
===== ./rewards/views_wheels.py =====
===== ./rewards/models.py =====
# rewards/models.py
from django.db import models
from accounts.models import Company
from dashboard.models import Client, Referral
import uuid
from django.urls import reverse

class ProbabilityWheel(models.Model):
    """
    Roue (pool) cyclique par entreprise.
    - key   : identifie un tirage (ex: 'base_100', 'very_rare_10000')
    - pool  : liste ordonnée des résultats (ex: ['SOUVENT','SOUVENT',...,'NO_HIT'])
    - idx   : curseur de consommation
    - size  : longueur totale du pool (copie pour debug)
    """
    company = models.ForeignKey(
        Company, on_delete=models.CASCADE, related_name="probability_wheels"
    )
    key = models.SlugField(max_length=64)
    pool = models.JSONField(default=list)
    idx = models.PositiveIntegerField(default=0)
    size = models.PositiveIntegerField(default=0)

    class Meta:
        unique_together = (("company", "key"),)
        indexes = [models.Index(fields=["company", "key"])]

    def __str__(self):
        return f"{self.company} • {self.key} ({self.idx}/{self.size})"


class RewardTemplate(models.Model):
    """
    Les 4 récompenses FIXES par entreprise : seules les infos 'métier' (nom, délai)
    sont éditables ; les probabilités restent gérées ailleurs (roue/poids).
    """
    BUCKETS = (
        ("SOUVENT", "Souvent"),
        ("MOYEN", "Moyen"),
        ("RARE", "Rare"),
        ("TRES_RARE", "Très rare"),
    )

    company = models.ForeignKey(
        Company, on_delete=models.CASCADE, related_name="reward_templates"
    )
    bucket = models.CharField(max_length=10, choices=BUCKETS)
    # nom affiché (modifiable par l’admin – ex “-10%”, “iPhone 16”, etc.)
    label = models.CharField(max_length=120, default="-10 % de remise")

    # délai choisi par l’admin en mois (1..6) + miroir en jours pour calculs
    cooldown_months = models.PositiveSmallIntegerField(default=1)
    cooldown_days = models.PositiveIntegerField(default=30)

    # uniquement pour affichage (ex “80/100”), calculé côté vue/service si tu préfères
    probability_display = models.CharField(max_length=20, default="", editable=False)

    class Meta:
        unique_together = (("company", "bucket"),)
        ordering = ("company", "bucket")

    def save(self, *args, **kwargs):
        # tient cooldown_days en phase avec cooldown_months
        self.cooldown_days = int(self.cooldown_months) * 30
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.company} • {self.get_bucket_display()} • {self.label}"

import secrets
from django.db import models
from django.utils import timezone
from django.urls import reverse


class Reward(models.Model):
    BUCKETS = (
        ("SOUVENT", "Souvent"),
        ("MOYEN", "Moyen"),
        ("RARE", "Rare"),
        ("TRES_RARE", "Très rare"),
    )
    STATE_CHOICES = (
        ("PENDING", "En attente"),
        ("SENT", "Envoyée"),
        ("DISABLED", "Désactivée"),
        ("ARCHIVED", "Archivée"),
    )

    company = models.ForeignKey(Company, on_delete=models.CASCADE, related_name="rewards")
    client = models.ForeignKey(Client, on_delete=models.CASCADE, related_name="rewards")

    # NEW: relie la récompense à un parrainage précis (permet d'appliquer la règle « 1 par filleul »)
    referral = models.ForeignKey(
        Referral, on_delete=models.CASCADE, related_name="rewards",
        null=True, blank=True
    )

    label = models.CharField(max_length=255)
    bucket = models.CharField(max_length=20, choices=BUCKETS)
    cooldown_days = models.PositiveIntegerField(default=0)
    state = models.CharField(max_length=20, choices=STATE_CHOICES, default="PENDING")
    created_at = models.DateTimeField(auto_now_add=True)
    token = models.CharField(max_length=64, unique=True, db_index=True, null=True, blank=True)
    token_expires_at = models.DateTimeField(null=True, blank=True)
    redeemed_at = models.DateTimeField(null=True, blank=True)
    redeemed_channel = models.CharField(max_length=20, blank=True)

    # ---- Helpers ----
   
    def ensure_token(self, force: bool = False):
        if force or not self.token:
            self.token = secrets.token_urlsafe(24)                # <-- plus de token_urlsafe
        if not self.token_expires_at:
            self.token_expires_at = timezone.now() + timezone.timedelta(days=180)

    class Meta:
        indexes = [models.Index(fields=["company", "client", "state"])]
        # Empêche 2 rewards pour le même parrain ET le même referral (donc même filleul)
        constraints = [
            models.UniqueConstraint(
                fields=["company", "client", "referral"],
                name="uniq_reward_by_referrer_and_referral",
            )
        ]
        
    @property
    def claim_path(self) -> str:
        return reverse("rewards:use_reward", kwargs={"token": self.token}) if self.token else ""

    def __str__(self):
        return f"{self.label} ({self.get_bucket_display()})"===== ./rewards/probabilities.py =====
from __future__ import annotations
from dataclasses import dataclass
from typing import Iterable, List, Tuple
from django.db import transaction
from django.utils.text import slugify
from rewards.models import ProbabilityWheel
from accounts.models import Company

# --------- Utilitaires de pool ----------
def build_pool(pairs: Iterable[Tuple[int, str]]) -> List[str]:
    """
    Construit une liste ordonnée à partir de paires (occurences, valeur).
    Exemple: [(80,'Souvent'), (20,'NO_HIT')] -> 100 cases.
    """
    pool: List[str] = []
    for n, val in pairs:
        if n < 0:
            raise ValueError("n négatif")
        pool.extend([val] * n)
    return pool

def interleave(pool: List[str]) -> List[str]:
    """
    Ré-ordonne le pool pour mieux répartir les valeurs (évite les clusters).
    Stratégie simple: round-robin par groupes.
    """
    # On groupe par valeur
    from collections import defaultdict, deque
    buckets = defaultdict(deque)
    for v in pool:
        buckets[v].append(v)

    # On itère tant qu'il reste des éléments
    keys = sorted(buckets.keys(), key=lambda k: -len(buckets[k]))
    out: List[str] = []
    while any(buckets[k] for k in keys):
        for k in keys:
            if buckets[k]:
                out.append(buckets[k].popleft())
    return out

# --------- API principale ----------
@dataclass
class WheelSpec:
    key: str
    # paires (occurences, label)
    pairs: Tuple[Tuple[int, str], ...]

def ensure_wheel(company: Company, spec: WheelSpec) -> ProbabilityWheel:
    """
    Crée ou met à jour la roue pour une entreprise donnée, selon la spec.
    """
    key = slugify(spec.key)
    raw = build_pool(spec.pairs)
    pool = interleave(raw) if len(set(raw)) > 1 else raw
    with transaction.atomic():
        obj, _created = ProbabilityWheel.objects.select_for_update().get_or_create(
            company=company, key=key, defaults={"pool": pool, "size": len(pool), "idx": 0}
        )
        # Si la taille/def change, on remplace
        if obj.size != len(pool) or obj.pool != pool:
            obj.pool = pool
            obj.size = len(pool)
            # on préserve l’idx modulo la nouvelle taille
            obj.idx = obj.idx % (len(pool) or 1)
            obj.save(update_fields=["pool", "size", "idx"])
    return obj

def draw(company: Company, key: str) -> str:
    """
    Tire le prochain élément de la roue (déterministe, tourniquet), puis avance l’idx.
    """
    k = slugify(key)
    with transaction.atomic():
        wheel = ProbabilityWheel.objects.select_for_update().get(company=company, key=k)
        if wheel.size == 0:
            raise ValueError("Roue vide")
        value = wheel.pool[wheel.idx]
        wheel.idx = (wheel.idx + 1) % wheel.size
        wheel.save(update_fields=["idx"])
        return value

# --------- Specs prêtes à l’emploi ----------
BASE_100 = WheelSpec(
    key="base_100",
    pairs=((80, "Souvent"), (19, "Moyen"), (1, "Rare")),
)
VERY_RARE_10000 = WheelSpec(
    key="very_rare_10000",
    pairs=((9999, "NO_HIT"), (1, "Très rare")),
)
===== ./rewards/tests/__init__.py =====
===== ./rewards/tests/test_smoke.py =====
from django.test import TestCase

class SmokeTest(TestCase):
    def test_truth(self):
        self.assertTrue(True)
===== ./rewards/tests/test_probability.py =====
import pytest
from accounts.models import Company
from rewards.services.probabilities import ensure_wheel, WheelSpec, draw

pytestmark = pytest.mark.django_db

def test_exact_ratio_80_100(client):
    company = Company.objects.create(name="Test Co")
    spec = WheelSpec(key="ratio_80_100", pairs=((80, "OK"), (20, "KO")))
    ensure_wheel(company, spec)
    hits = [draw(company, "ratio_80_100") for _ in range(100)]
    assert hits.count("OK") == 80
    assert hits.count("KO") == 20
===== ./rewards/management/ __init__.py =====
===== ./rewards/management/commands/init_probability_wheels.py =====
from django.core.management.base import BaseCommand, CommandError
from accounts.models import Company
from rewards.services.probabilities import ensure_wheel, BASE_100, VERY_RARE_10000

class Command(BaseCommand):
    help = "Initialise les roues de probabilité pour une entreprise."

    def add_arguments(self, parser):
        parser.add_argument("--company", required=True, help="Slug de l'entreprise")

    def handle(self, *args, **options):
        slug = options["company"]
        try:
            company = Company.objects.get(slug=slug)
        except Company.DoesNotExist:
            raise CommandError(f"Company '{slug}' introuvable")

        specs = [BASE_100, VERY_RARE_10000]
        for spec in specs:
            ensure_wheel(company, spec)
            self.stdout.write(self.style.SUCCESS(f"OK: {company} • {spec.key}"))
===== ./rewards/management/commands/seed_wheels.py =====
from django.core.management.base import BaseCommand
from accounts.models import Company
from rewards.services.probabilities import ensure_wheels_for_company

class Command(BaseCommand):
    help = "Initialise (ou ré-initialise) les roues de probabilités pour chaque entreprise."

    def add_arguments(self, parser):
        parser.add_argument(
            "--reset",
            action="store_true",
            help="Ré-initialise les roues (réécrit le pool et remet idx=0)."
        )

    def handle(self, *args, **options):
        reset = options["reset"]
        count = 0
        for company in Company.objects.all():
            ensure_wheels_for_company(company)
            count += 1
        self.stdout.write(self.style.SUCCESS(
            f"Roues initialisées pour {count} entreprise(s)."
        ))
        if reset:
            # Optionnel : si tu veux forcer un reset plus fort, tu peux
            # étendre ensure_wheels_for_company pour régénérer les pools
            self.stdout.write(self.style.WARNING(
                "Option --reset indiquée : assure-toi que ensure_wheels_for_company "
                "régénère les pools comme attendu."
            ))
===== ./rewards/management/commands/ __init__.py =====
===== ./rewards/management/commands/rebuild_wheels.py =====
from django.core.management.base import BaseCommand
from accounts.models import Company
from rewards.services.probabilities import get_or_build_wheel, DEFAULT_WEIGHTS

class Command(BaseCommand):
    help = "Reconstruit/initialise les roues de probabilité pour chaque entreprise."

    def handle(self, *args, **opts):
        for c in Company.objects.filter(is_active=True):
            wheel = get_or_build_wheel(c, DEFAULT_WEIGHTS)
            self.stdout.write(self.style.SUCCESS(f"{c.name}: {wheel.key} ({wheel.size} cases)"))
===== ./rewards/__init__.py =====
===== ./rewards/apps.py =====
# rewards/apps.py
from django.apps import AppConfig

class RewardsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "rewards"
    verbose_name = "Récompenses"

    def ready(self):
        import rewards.signals  # <-- le bon import
===== ./rewards/forms.py =====
from django import forms
from .models import RewardTemplate

class RewardTemplateForm(forms.ModelForm):
    # TypedChoiceField so we store an integer, not a string
    cooldown_months = forms.TypedChoiceField(
        choices=[(i, f"{i} mois") for i in range(1, 7)],
        coerce=int,
        label="Délai",
        widget=forms.Select(attrs={"class": "form-select"})  # <-- Bootstrap styling here
    )

    class Meta:
        model = RewardTemplate
        fields = ("label", "cooldown_months")
        labels = {"label": "Nom de la récompense"}
        widgets = {
            "label": forms.TextInput(
                attrs={"class": "form-control", "placeholder": "Ex. -10 %"}
            ),
        }

===== ./rewards/admin.py =====
# rewards/admin.py
from django.contrib import admin, messages
from django.db import IntegrityError, transaction
from django.utils.translation import gettext_lazy as _

from .models import ProbabilityWheel, RewardTemplate, Reward
# Services pour piloter les roues depuis l’admin
from .services.probabilities import (
    BASE_KEY, VERY_RARE_KEY,
    ensure_wheels, rebuild_wheel, reset_wheel
)


# ============ Actions utilitaires ============

@admin.action(description="Marquer sélection comme Envoyée")
def mark_sent(modeladmin, request, queryset):
    updated = queryset.update(state="SENT")
    messages.success(request, _(f"{updated} récompense(s) marquée(s) comme envoyée(s)."))

@admin.action(description="Marquer sélection comme En attente")
def mark_pending(modeladmin, request, queryset):
    updated = queryset.update(state="PENDING")
    messages.success(request, _(f"{updated} récompense(s) marquée(s) comme en attente."))

@admin.action(description="Marquer sélection comme Désactivée")
def mark_disabled(modeladmin, request, queryset):
    updated = queryset.update(state="DISABLED")
    messages.success(request, _(f"{updated} récompense(s) désactivée(s)."))

@admin.action(description="Archiver la sélection")
def mark_archived(modeladmin, request, queryset):
    updated = queryset.update(state="ARCHIVED")
    messages.success(request, _(f"{updated} récompense(s) archivée(s)."))


# ============ Reward ============

@admin.register(Reward)
class RewardAdmin(admin.ModelAdmin):
    """
    Gestion des récompenses instanciées (par client).
    - Recherche par client / email / libellé
    - Filtres par entreprise / type / état / date
    - Actions de changement d’état
    """
    list_display = (
        "company", "client", "referral",
        "label", "bucket", "state", "created_at",
    )
    list_filter = (
        "company", "bucket", "state", ("created_at", admin.DateFieldListFilter),
    )
    search_fields = (
        "label",
        "client__last_name", "client__first_name",
        "client__email", "client__phone",
    )
    list_select_related = ("company", "client", "referral")
    autocomplete_fields = ("client", "referral")
    raw_id_fields = ()
    date_hierarchy = "created_at"
    ordering = ("-created_at", "-id")
    actions = [mark_sent, mark_pending, mark_disabled, mark_archived]

    # Optionnel: protéger la contrainte unique (company, client, referral) côté admin
    def save_model(self, request, obj, form, change):
        try:
            with transaction.atomic():
                super().save_model(request, obj, form, change)
        except IntegrityError:
            self.message_user(
                request,
                _("Une récompense existe déjà pour ce parrainage et ce parrain (règle: 1 par filleul)."),
                level=messages.ERROR,
            )


# ============ RewardTemplate ============

@admin.register(RewardTemplate)
class RewardTemplateAdmin(admin.ModelAdmin):
    """
    Les 4 templates fixes par entreprise.
    - Seuls label + cooldown_months sont modifiables.
    - Affiche cooldown_days et probability_display en lecture seule.
    """
    list_display = (
        "company", "bucket", "label",
        "cooldown_months", "cooldown_days", "probability_display",
    )
    list_filter = ("company", "bucket")
    search_fields = ("label", "company__name")
    ordering = ("company", "bucket")
    readonly_fields = ("cooldown_days", "probability_display")


# ============ ProbabilityWheel ============

@admin.action(description="(Re)créer les deux roues pour l’entreprise (ensure_wheels)")
def action_ensure_wheels(modeladmin, request, queryset):
    """
    Pour chaque roue sélectionnée, on régénère (idempotent) les DEUX roues
    de l’entreprise afin d’assurer les tailles exactes (base et very_rare).
    """
    companies = {w.company for w in queryset}
    for c in companies:
        ensure_wheels(c)
    messages.success(request, _(f"Roues vérifiées/régénérées pour {len(companies)} entreprise(s)."))

@admin.action(description="Régénérer la roue sélectionnée (repart à idx=0)")
def action_rebuild_selected(modeladmin, request, queryset):
    for w in queryset:
        key = w.key
        try:
            rebuild_wheel(w.company, key)
        except ValueError:
            messages.error(request, _(f"Clé inconnue pour {w}: {key}"))
    messages.success(request, _("Roue(s) régénérée(s)."))

@admin.action(description="Remettre le curseur (idx) à 0")
def action_reset_idx(modeladmin, request, queryset):
    for w in queryset:
        reset_wheel(w.company, w.key)
    messages.success(request, _("Curseur réinitialisé à 0 pour la sélection."))


@admin.register(ProbabilityWheel)
class ProbabilityWheelAdmin(admin.ModelAdmin):
    """
    Visualisation et maintenance des roues.
    """
    list_display = ("company", "key", "size", "idx")
    list_filter = ("company", "key")
    search_fields = ("company__name", "key")
    readonly_fields = ("size", "idx")
    actions = [action_ensure_wheels, action_rebuild_selected, action_reset_idx]
===== ./rewards/utils.py =====
from django import template
register = template.Library()

@register.filter
def get_item(d, key):
    try:
        return d.get(key)
    except Exception:
        return None
===== ./rewards/urls.py =====
# rewards/urls.py
from django.urls import path
from .views import reward_list, reward_update, referral_delete, reward_spin, rewards_history_company, use_reward

app_name = "rewards"

urlpatterns = [
    path("", reward_list, name="list"),
    path("<int:pk>/edit/", reward_update, name="update"),
    path("referrals/<int:pk>/delete/", referral_delete, name="referral_delete"),
    # NEW: page d’animation de la roue pour une Reward donnée
    path("spin/<int:reward_id>/", reward_spin, name="spin"),
    path("history/", rewards_history_company, name="history_company"),
    path("use/<str:token>/", use_reward, name="use_reward")
]
===== ./rewards/services/probabilities.py =====
# rewards/services/probabilities.py
from __future__ import annotations
from dataclasses import dataclass
from typing import Dict, List, Tuple

from django.db import transaction

from accounts.models import Company
from rewards.models import ProbabilityWheel

# ⚠️ On garde les mêmes clés pour compatibilité (vues/templates/urls),
#    mais on va désormais construire des pools de 1000 et 100_000 cases.
BASE_KEY = "base_100"
VERY_RARE_KEY = "very_rare_10000"

# Tokens standardisés
SOUVENT = "SOUVENT"
MOYEN = "MOYEN"
RARE = "RARE"
TRES_RARE = "TRES_RARE"
NO_HIT = "NO_HIT"

# -----------------------------
#   Composition EXACTE des pools
# -----------------------------
# Base = 1000 cases -> Rare = 1/1000 (0,1 %)
# Répartition choisie (simple et lisible) :
#   - 980 x Souvent
#   -  19 x Moyen
#   -   1 x Rare
BASE_COUNTS = {
    SOUVENT: 980,
    MOYEN: 19,
    RARE: 1,
}
BASE_SIZE = sum(BASE_COUNTS.values())  # 1000

# Très rare = 100_000 cases -> 1/100_000 (0,001 %)
VR_COUNTS = {
    NO_HIT: 100_000 - 1,
    TRES_RARE: 1,
}
VR_SIZE = sum(VR_COUNTS.values())  # 100_000


def _build_base_pool() -> List[str]:
    pool: List[str] = []
    for token, n in BASE_COUNTS.items():
        pool.extend([token] * n)
    return pool


def _build_very_rare_pool() -> List[str]:
    pool: List[str] = []
    for token, n in VR_COUNTS.items():
        pool.extend([token] * n)
    return pool


@transaction.atomic
def ensure_wheels(company: Company) -> Tuple[ProbabilityWheel, ProbabilityWheel]:
    """
    Crée (ou met à niveau) les deux roues pour l’entreprise.
    - BASE_KEY      -> 1000 cases (980/19/1)
    - VERY_RARE_KEY -> 100_000 cases (1 TRES_RARE)
    """
    base, _ = ProbabilityWheel.objects.get_or_create(
        company=company,
        key=BASE_KEY,
        defaults={"pool": _build_base_pool(), "size": BASE_SIZE, "idx": 0},
    )
    very_rare, _ = ProbabilityWheel.objects.get_or_create(
        company=company,
        key=VERY_RARE_KEY,
        defaults={"pool": _build_very_rare_pool(), "size": VR_SIZE, "idx": 0},
    )

    # Mise à niveau si l’ancienne taille (100 / 10_000) est encore en base
    if base.size != BASE_SIZE:
        base.pool, base.size, base.idx = _build_base_pool(), BASE_SIZE, 0
        base.save(update_fields=["pool", "size", "idx"])

    if very_rare.size != VR_SIZE:
        very_rare.pool, very_rare.size, very_rare.idx = _build_very_rare_pool(), VR_SIZE, 0
        very_rare.save(update_fields=["pool", "size", "idx"])

    return base, very_rare


def rebuild_wheel(company: Company, key: str) -> None:
    """Régénère entièrement une roue (repart à idx=0)."""
    if key == BASE_KEY:
        pool, size = _build_base_pool(), BASE_SIZE
    elif key == VERY_RARE_KEY:
        pool, size = _build_very_rare_pool(), VR_SIZE
    else:
        raise ValueError(f"Clé de roue inconnue: {key}")

    ProbabilityWheel.objects.update_or_create(
        company=company, key=key,
        defaults={"pool": pool, "size": size, "idx": 0}
    )


def reset_wheel(company: Company, key: str) -> None:
    """Remet le curseur à zéro (sans toucher la composition)."""
    wheel = ProbabilityWheel.objects.get(company=company, key=key)
    wheel.idx = 0
    wheel.save(update_fields=["idx"])


def _consume_one(wheel: ProbabilityWheel) -> str:
    value = wheel.pool[wheel.idx]
    wheel.idx = (wheel.idx + 1) % wheel.size
    wheel.save(update_fields=["idx"])
    return value


def tirer_recompense(company: Company) -> str:
    """
    Tirage déterministe EXACT (pas d’aléatoire) :
      1) On consomme la roue VERY_RARE_KEY (1 / 100_000 par cycle).
         -> si TRES_RARE : on retourne immédiatement TRES_RARE
      2) Sinon, on consomme la roue BASE_KEY (980/19/1 sur 1000 exactement).
    """
    base, very_rare = ensure_wheels(company)
    vr = _consume_one(very_rare)
    if vr == TRES_RARE:
        return TRES_RARE
    return _consume_one(base)


@dataclass
class WheelSnapshot:
    size: int
    idx: int
    progress_pct: int
    remaining_by_token: Dict[str, int]
    total_by_token: Dict[str, int]


def _remaining_counts(pool: List[str], idx: int, tokens: List[str]) -> Dict[str, int]:
    """Compte ce qu'il reste AVANT la fin du cycle actuel (de idx -> fin)."""
    tail = pool[idx:]
    out: Dict[str, int] = {}
    for t in tokens:
        out[t] = tail.count(t)
    return out


def get_snapshot(company: Company) -> Dict[str, WheelSnapshot]:
    """Données pour l’UI (progression et restants par token)."""
    base, very_rare = ensure_wheels(company)

    base_tokens = [SOUVENT, MOYEN, RARE]
    base_total = {t: base.pool.count(t) for t in base_tokens}
    base_remaining = _remaining_counts(base.pool, base.idx, base_tokens)

    vr_tokens = [TRES_RARE, NO_HIT]
    vr_total = {t: very_rare.pool.count(t) for t in vr_tokens}
    vr_remaining = _remaining_counts(very_rare.pool, very_rare.idx, vr_tokens)

    return {
        "base": WheelSnapshot(
            size=base.size,
            idx=base.idx,
            progress_pct=int((base.idx / base.size) * 100) if base.size else 0,
            remaining_by_token=base_remaining,
            total_by_token=base_total,
        ),
        "very_rare": WheelSnapshot(
            size=very_rare.size,
            idx=very_rare.idx,
            progress_pct=int((very_rare.idx / very_rare.size) * 100) if very_rare.size else 0,
            remaining_by_token=vr_remaining,
            total_by_token=vr_total,
        ),
    }
===== ./rewards/views.py =====
# rewards/views.py
from django.contrib.auth.decorators import login_required
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages

from accounts.models import Company
from .models import RewardTemplate,Reward
from .forms import RewardTemplateForm
from dashboard.models import Referral
from django.views.decorators.http import require_POST

BUCKET_UI = {
    "SOUVENT":   {"label": "Souvent",   "badge": "success", "prob": "980/1000"},
    "MOYEN":     {"label": "Moyen",     "badge": "info",    "prob": "19/1000"},
    "RARE":      {"label": "Rare",      "badge": "warning", "prob": "1/1000"},
    "TRES_RARE": {"label": "Très rare", "badge": "danger",  "prob": "1/100000"},
}

def _current_company(request):
    # super simple : admin entreprise = user.company ; superadmin -> ?company=<id>
    user = request.user
    company = getattr(user, "company", None)
    cid = (request.GET.get("company") or "").strip()
    if getattr(user, "is_superadmin", lambda: False)() and cid:
        company = get_object_or_404(Company, pk=cid)
    return company

def ensure_reward_templates(company):
    """Crée les 4 lignes si manquantes, avec proba figées."""
    for key, ui in BUCKET_UI.items():
        obj, created = RewardTemplate.objects.get_or_create(
            company=company, bucket=key,
            defaults={
                "label": "- 10 % de remise" if key in ("SOUVENT", "MOYEN") else (
                    "iPhone 16 Pro Max" if key=="RARE" else "Voyage à Miami"
                ),
                "cooldown_months": 1 if key in ("SOUVENT", "MOYEN") else (3 if key=="RARE" else 6),
                "probability_display": ui["prob"],
            }
        )
        # si la ligne existe mais le texte affiché est vide (ancienne data), on le remet
        if not obj.probability_display:
            obj.probability_display = ui["prob"]
            obj.save(update_fields=["probability_display"])

@login_required
def reward_list(request):
    company = _current_company(request)
    if not company:
        messages.error(request, "Aucune entreprise sélectionnée.")
        return redirect("dashboard:root")

    ensure_reward_templates(company)
    items = RewardTemplate.objects.filter(company=company)

    # ordre voulu : Souvent → Moyen → Rare → Très rare
    order = {"SOUVENT": 0, "MOYEN": 1, "RARE": 2, "TRES_RARE": 3}
    items = sorted(items, key=lambda r: order.get(r.bucket, 99))

    # pour l’affichage couleur/badge
    items = [
        (r, BUCKET_UI[r.bucket])
        for r in items
    ]
    return render(request, "rewards/list.html", {"items": items})

@login_required
def reward_update(request, pk):
    company = _current_company(request)
    r = get_object_or_404(RewardTemplate, pk=pk, company=company)
    if request.method == "POST":
        form = RewardTemplateForm(request.POST, instance=r)
        if form.is_valid():
            form.save()
            messages.success(request, "Récompense mise à jour.")
            return redirect("rewards:list")
    else:
        form = RewardTemplateForm(instance=r)
    return render(request, "rewards/form.html", {"form": form, "tpl": r, "ui": BUCKET_UI[r.bucket]})


def _can_manage_company(user, company) -> bool:
    return (hasattr(user, "is_superadmin") and user.is_superadmin()) or (
        hasattr(user, "company") and user.company_id == company.id
    )

@login_required
@require_POST
def referral_delete(request, pk: int):
    referral = get_object_or_404(Referral.objects.select_related("company", "referrer", "referee"), pk=pk)

    # sécurité : périmètre entreprise
    if not _can_manage_company(request.user, referral.company):
        messages.error(request, "Accès refusé.")
        # on tente de revenir sur la fiche passée en paramètre, sinon liste
        back_id = request.POST.get("back_client")
        return redirect("dashboard:client_detail", pk=back_id) if back_id else redirect("dashboard:clients_list")

    # pour le redirect, on récupère la fiche d’où on a cliqué
    back_client_id = request.POST.get("back_client") or referral.referee_id or referral.referrer_id

    referral.delete()
    messages.success(request, "Parrainage supprimé.")
    return redirect("dashboard:client_detail", pk=back_client_id)


# rewards/views.py (ajoute en haut)
from .models import Reward  # pour charger la récompense réelle

# ...

@login_required
def reward_spin(request, reward_id: int):
    """
    Page avec une roue animée et des couleurs qui correspondent au type de récompense.
    - Segments fixes (SOUVENT/MOYEN/RARE/TRES_RARE) en vert/bleu/orange/rouge.
    - Aiguille, bordure et lueur teintent selon la "badge" (success/info/warning/danger).
    """
    reward = get_object_or_404(
        Reward.objects.select_related("company", "client"),
        pk=reward_id
    )

    # Ordre des 4 segments (90° par segment) :
    wheel_order = ["SOUVENT", "MOYEN", "RARE", "TRES_RARE"]
    segment = 360 / len(wheel_order)  # 90°
    try:
        idx = wheel_order.index(reward.bucket)
    except ValueError:
        idx = 0

    # 4 tours complets + position au centre du segment cible
    target_angle = 4 * 360 + int(idx * segment + segment / 2)

    ui = BUCKET_UI.get(reward.bucket, {"label": reward.bucket, "badge": "secondary"})
    return render(request, "rewards/spin.html", {
        "reward": reward,
        "ui": ui,                   # -> success/info/warning/danger
        "target_angle": target_angle,
    })
    
    
    # rewards/views.py
from django.db.models import Q
from django.core.paginator import Paginator
from django.contrib.auth.decorators import login_required

STATE_UI = {
    "PENDING":  {"label": "En attente",   "badge": "warning"},
    "SENT":     {"label": "Envoyée",      "badge": "success"},
    "DISABLED": {"label": "Désactivée",   "badge": "secondary"},
    "ARCHIVED": {"label": "Archivée",     "badge": "dark"},
}

@login_required
def rewards_history_company(request):
    """
    Historique de TOUTES les récompenses d'une entreprise (tous les clients).
    Filtres: bucket, état, recherche. Pagination.
    """
    company = _current_company(request)
    if not company:
        messages.error(request, "Aucune entreprise sélectionnée.")
        return redirect("dashboard:root")

    qs = (Reward.objects
          .select_related("client")
          .filter(company=company)
          .order_by("-created_at", "-id"))

    # filtres GET
    bucket = (request.GET.get("bucket") or "").strip().upper()
    state  = (request.GET.get("state") or "").strip().upper()
    q      = (request.GET.get("q") or "").strip()

    if bucket in BUCKET_UI.keys():
        qs = qs.filter(bucket=bucket)
    if state in STATE_UI.keys():
        qs = qs.filter(state=state)
    if q:
        qs = qs.filter(
            Q(client__first_name__icontains=q) |
            Q(client__last_name__icontains=q)  |
            Q(client__email__icontains=q)      |
            Q(label__icontains=q)
        )

    page = Paginator(qs, 20).get_page(request.GET.get("p"))

    return render(request, "rewards/history.html", {
        "company": company,
        "page": page,
        "bucket": bucket,
        "state": state,
        "q": q,
        "BUCKET_UI": BUCKET_UI,
        "STATE_UI": STATE_UI,
        "buckets": [(k, v["label"]) for k, v in BUCKET_UI.items()],
        "states": [(k, v["label"]) for k, v in STATE_UI.items()],
    })

from django.utils import timezone
from django.shortcuts import render, get_object_or_404
from .models import Reward

def use_reward(request, token):
    reward = get_object_or_404(Reward, token=token, state="PENDING")

    reward.state = "SENT"
    reward.redeemed_at = timezone.now()
    reward.save(update_fields=["state", "redeemed_at"])

    messages.success(request, f"Vous venez d’utiliser votre récompense : {reward.label}")
    return render(request, "rewards/use_reward_done.html", {"reward": reward})
===== ./templates/rewards/form.html =====
{# templates/rewards/form.html #}
{% extends "base_dashboard.html" %}
{% block title %}Modifier une récompense • ParrainApp{% endblock %}
{% block body_data_page %}recompenses{% endblock %}

{% block content %}
<header class="mb-3">
  <h1 class="h4 section-title mb-1">Modifier « {{ tpl.label }} » ({{ ui.label }})</h1>
  <div class="text-secondary">Probabilité : ~{{ tpl.probability_display }} (fixe)</div>
</header>

<div class="card shadow-sm">
  <form method="post" class="card-body vstack gap-3">
    {% csrf_token %}
    <div class="row g-3">
      <div class="col-md-6">
        <label for="{{ form.label.id_for_label }}" class="form-label">Nom de la récompense</label>
        {{ form.label }}
      </div>
      <div class="col-md-6">
        <label for="{{ form.cooldown_months.id_for_label }}" class="form-label">Délai</label>
        {{ form.cooldown_months }}  {# renders with class="form-select" #}
      </div>
    </div>

    <div class="d-flex justify-content-end gap-2 mt-3">
      <a href="{% url 'rewards:list' %}" class="btn btn-outline-secondary">Annuler</a>
      <button type="submit" class="btn btn-primary">Enregistrer</button>
    </div>
  </form>
</div>

{% endblock %}
===== ./templates/rewards/wheels.html =====
{# templates/rewards/wheels.html #}
{% extends "base_dashboard.html" %}
{% block title %}Roue de probabilités • ParrainApp{% endblock %}
{% block body_data_page %}recompenses{% endblock %}

{% block content %}

{# Mini override pour “orange” Bootstrap (Rare) #}
<style>
  .text-bg-orange{color:#fff!important;background-color:#fd7e14!important}
  .bg-orange-subtle{background-color:rgba(253,126,20,.15)!important}
</style>

<header class="mb-4">
  <h1 class="h4 section-title mb-1">Roue de probabilités</h1>
  <div class="text-secondary">Exactement 80/100, 19/100, 1/100 et 1/10000 par entreprise.</div>
</header>

<div class="d-flex justify-content-end mb-3">
  {# même placement que “Ajouter une récompense” dans ta maquette #}
  <form method="post" action="{% url 'rewards:wheel_rebuild' base_key %}" class="me-2">
    {% csrf_token %}
    <button class="btn btn-outline-primary">Régénérer base (100)</button>
  </form>
  <form method="post" action="{% url 'rewards:wheel_rebuild' vr_key %}">
    {% csrf_token %}
    <button class="btn btn-outline-danger">Régénérer très rare (10 000)</button>
  </form>
</div>

<div class="row g-3">
  {# On reprend exactement la grille de 4 cards #}
  {% for c in cards %}
  <div class="col-md-6 col-xl-3">
    <div class="card h-100 shadow-sm">
      <div class="card-header d-flex justify-content-between
           {% if c.code == 'souvent' %}bg-success-subtle
           {% elif c.code == 'moyen' %}bg-warning-subtle
           {% elif c.code == 'rare' %}bg-orange-subtle
           {% else %}bg-danger-subtle
           {% endif %}">
        <span class="badge {{ c.badge_cl }}">{{ c.title }}</span>
        <small class="text-secondary">{{ c.approx }}</small>
      </div>
      <div class="card-body d-flex flex-column">
        <h3 class="h6">{{ c.title }} — restants dans le cycle : {{ c.remaining }} / {{ c.total }}</h3>
        <div class="text-secondary small mb-3">
          Curseur de la roue :
          <strong>{{ c.progress }}%</strong>
        </div>

        <div class="progress mb-3" style="height:6px">
          <div class="progress-bar" style="width: {{ c.progress }}%"></div>
        </div>

        <div class="mt-auto d-flex flex-wrap gap-2">
          {% if c.code in 'souvent,moyen,rare' %}
            <form method="post" action="{% url 'rewards:wheel_reset' base_key %}">
              {% csrf_token %}<button class="btn btn-sm btn-outline-secondary">Remettre à zéro (base)</button>
            </form>
            <form method="post" action="{% url 'rewards:wheel_consume' base_key %}">
              {% csrf_token %}<button class="btn btn-sm btn-outline-primary">Consommer 1 tirage (test)</button>
            </form>
          {% else %}
            <form method="post" action="{% url 'rewards:wheel_reset' vr_key %}">
              {% csrf_token %}<button class="btn btn-sm btn-outline-secondary">Remettre à zéro (très rare)</button>
            </form>
            <form method="post" action="{% url 'rewards:wheel_consume' vr_key %}">
              {% csrf_token %}<button class="btn btn-sm btn-outline-primary">Consommer 1 tirage (test)</button>
            </form>
          {% endif %}
        </div>
      </div>
    </div>
  </div>
  {% endfor %}
</div>

{% endblock %}
===== ./templates/rewards/spin.html =====
{% extends "base_dashboard.html" %}
{% block title %}Roulette de récompense • ParrainApp{% endblock %}
{% block body_data_page %}recompenses{% endblock %}

{% block content %}
<style>
/* --------- Variables de teinte ---------- */
.wheel {
  --accent: #6c757d; /* fallback */
  width: 300px; height: 300px;
  border-radius: 50%;
  border: 8px solid var(--accent);
  position: relative;
  margin: 0 auto;
  box-shadow:
    0 0 0 4px rgba(0,0,0,.03),
    0 0 30px rgba(0,0,0,.06) inset;
  transition: box-shadow .3s ease, border-color .3s ease;
}
.wheel.is-spinning { box-shadow: 0 0 0 4px rgba(0,0,0,.03), 0 0 46px var(--accent); }

/* Aiguille (triangle en haut) */
.wheel::after{
  content:"";
  position:absolute; top:-20px; left:50%; transform:translateX(-50%);
  width:0; height:0;
  border-left: 12px solid transparent;
  border-right:12px solid transparent;
  border-bottom:22px solid var(--accent);
  filter: drop-shadow(0 2px 0 rgba(0,0,0,.15));
}

/* Disque interne : conic-gradient 4 segments dans l’ordre SOUVENT/MOYEN/RARE/TRES_RARE */
.wheel__disk{
  position:absolute; inset: 16px;
  border-radius:50%;
  background:
    conic-gradient(
      rgba(25,135,84,.90) 0deg,   rgba(25,135,84,.90) 90deg,   /* success  -> SOUVENT */
      rgba(13,202,240,.90) 90deg, rgba(13,202,240,.90) 180deg, /* info     -> MOYEN   */
      rgba(253,126,20,.92) 180deg,rgba(253,126,20,.92) 270deg, /* orange   -> RARE    */
      rgba(220,53,69,.92) 270deg, rgba(220,53,69,.92) 360deg   /* danger   -> TRES_RARE */
    );
  transform-origin:50% 50%;
}

/* Animation de rotation */
.spin-anim { transition: transform 2.2s cubic-bezier(.17,.67,.13,1.02); }

/* Map badge -> couleur d’accent */
.wheel--success { --accent:#198754; } /* vert   */
.wheel--info    { --accent:#0dcaf0; } /* bleu   */
.wheel--warning { --accent:#fd7e14; } /* orange */
.wheel--danger  { --accent:#dc3545; } /* rouge  */

/* Carte résultat */
.result-card { border-left: 4px solid var(--accent); }
</style>

<header class="mb-4 d-flex justify-content-between align-items-center">
  <div>
    <h1 class="h5 mb-1">Animation de la roue</h1>
    <div class="text-secondary">
      Récompense attribuée à <strong>{{ reward.client.last_name }} {{ reward.client.first_name }}</strong>
    </div>
  </div>
  <a class="btn btn-outline-secondary" href="{% url 'dashboard:client_detail' pk=reward.client_id %}">Retour fiche client</a>
</header>

<div class="card shadow-sm">
  <div class="card-body d-flex flex-column align-items-center">
    {# La classe wheel--{{ ui.badge }} pose la bonne couleur (success/info/warning/danger) #}
    <div class="wheel wheel--{{ ui.badge }} is-spinning">
      <div id="disk" class="wheel__disk spin-anim"></div>
    </div>

    <div class="mt-4 text-center result-card px-3 py-2 rounded">
      <span class="badge text-bg-{{ ui.badge }} me-2">{{ ui.label }}</span>
      <strong id="rewardLabel">{{ reward.label }}</strong>
    </div>
  </div>
</div>

<script>
(function(){
  const disk = document.getElementById('disk');
  const target = {{ target_angle|default:1440 }};
  // Lance la rotation après un mini délai pour laisser le layout se peindre
  setTimeout(()=>{ disk.style.transform = `rotate(${target}deg)`; }, 60);
  // Retire l'état “is-spinning” une fois l’animation finie (effet de lueur)
  disk.addEventListener('transitionend', () => {
    const wheel = disk.closest('.wheel');
    wheel && wheel.classList.remove('is-spinning');
  }, { once: true });
})();
</script>
{% endblock %}
===== ./templates/rewards/list.html =====
{# templates/rewards/list.html #}
{% extends "base_dashboard.html" %}
{% block title %}Récompenses • ParrainApp{% endblock %}
{% block body_data_page %}recompenses{% endblock %}

{% block content %}
<header class="mb-4">
  <h1 class="h4 section-title mb-1">Récompenses</h1>
  <div class="text-secondary">Définissez les cadeaux (nom) et le délai. Les probabilités sont fixes.</div>
</header>

{% if not items %}
  <div class="card shadow-sm"><div class="card-body text-secondary">Aucune récompense.</div></div>
{% else %}
  <div class="row g-3">
    {% for r, ui in items %}
      <div class="col-md-6 col-xl-3">
        <div class="card h-100 shadow-sm">
          <div class="card-header bg-{{ ui.badge }}-subtle d-flex justify-content-between">
            <span class="badge text-bg-{{ ui.badge }}">
              {% if ui.label == "Moyen" %}Moyen{% else %}{{ ui.label }}{% endif %}
            </span>
            <small class="text-secondary">~{{ r.probability_display }}</small>
          </div>
          <div class="card-body d-flex flex-column">
            <h3 class="h6">{{ r.label }}</h3>
            <div class="text-secondary small mb-3">
              Délai : {{ r.cooldown_months }} mois
            </div>
            <div class="mt-auto d-flex gap-2">
              <a class="btn btn-sm btn-outline-primary" href="{% url 'rewards:update' r.pk %}">Modifier</a>
            </div>
          </div>
        </div>
      </div>
    {% endfor %}
  </div>
{% endif %}
{% endblock %}
===== ./templates/rewards/history.html =====
{% extends "base_dashboard.html" %}
{% block title %}Historique des récompenses • {{ company.name }}{% endblock %}
{% block body_data_page %}recompenses{% endblock %}

{% block content %}
<header class="mb-4">
  <h1 class="h4 section-title mb-2">Historique des récompenses — {{ company.name }}</h1>
  <div class="text-secondary">Toutes les récompenses de l’entreprise, tous clients confondus.</div>
</header>

<div class="card shadow-sm mb-3">
  <div class="card-body">
    <form method="get" class="row g-2 align-items-end">
      <div class="col-lg-3">
        <label class="form-label mb-1">Type</label>
        <select name="bucket" class="form-select">
          <option value="">— Tous —</option>
          {% for k, lbl in buckets %}
            <option value="{{ k }}" {% if k == bucket %}selected{% endif %}>
              {{ BUCKET_UI.k.label|default:lbl }}
            </option>
          {% endfor %}
        </select>
      </div>

      <div class="col-lg-3">
        <label class="form-label mb-1">État</label>
        <select name="state" class="form-select">
          <option value="">— Tous —</option>
          {% for k, lbl in states %}
            <option value="{{ k }}" {% if k == state %}selected{% endif %}>
              {{ STATE_UI.k.label|default:lbl }}
            </option>
          {% endfor %}
        </select>
      </div>

      <div class="col-lg-4">
        <label class="form-label mb-1">Recherche</label>
        <input type="text" name="q" value="{{ q }}" class="form-control"
               placeholder="Client (nom/prénom/email) ou libellé de récompense…">
      </div>

      <div class="col-lg-2 d-flex gap-2">
        <button class="btn btn-primary w-100" type="submit">Filtrer</button>
        <a class="btn btn-outline-secondary" href="{% url 'rewards:history_company' %}">Réinitialiser</a>
      </div>
    </form>
  </div>
</div>

{% if page and page.object_list %}
  <div class="card shadow-sm">
    <div class="table-responsive">
      <table class="table align-middle mb-0">
        <thead class="table-light">
          <tr>
            <th style="width: 140px;">Date</th>
            <th>Client</th>
            <th>Récompense</th>
            <th style="width: 130px;">Type</th>
            <th style="width: 130px;">État</th>
          </tr>
        </thead>
        <tbody>
          {% for r in page.object_list %}
            <tr>
              <td>
                <div class="small">{{ r.created_at|date:"d/m/Y" }}</div>
                <div class="text-secondary small">{{ r.created_at|date:"H:i" }}</div>
              </td>
              <td>
                <div class="fw-semibold">
                  <a href="{% url 'dashboard:client_detail' pk=r.client_id %}" class="text-decoration-none">
                    {{ r.client.last_name }} {{ r.client.first_name }}
                  </a>
                </div>
                <div class="text-secondary small">{{ r.client.email|default:"—" }}</div>
              </td>
              <td><div class="fw-semibold">{{ r.label }}</div></td>
              <td>
                {% with ui=BUCKET_UI.r.bucket %}
                  <span class="badge text-bg-{{ ui.badge|default:'secondary' }}">{{ ui.label|default:r.bucket }}</span>
                {% endwith %}
              </td>
              <td>
                {% with st=STATE_UI.r.state %}
                  <span class="badge text-bg-{{ st.badge|default:'secondary' }}">{{ st.label|default:r.state }}</span>
                {% endwith %}
              </td>
            </tr>
          {% endfor %}
        </tbody>
      </table>
    </div>

    {% if page.paginator.num_pages > 1 %}
      <div class="card-footer bg-transparent d-flex justify-content-end align-items-center gap-2">
        {% if page.has_previous %}
          <a class="btn btn-sm btn-outline-secondary"
             href="?p={{ page.previous_page_number }}&bucket={{ bucket }}&state={{ state }}&q={{ q|urlencode }}">
            Préc.
          </a>
        {% endif %}
        <span class="small">Page {{ page.number }}/{{ page.paginator.num_pages }}</span>
        {% if page.has_next %}
          <a class="btn btn-sm btn-outline-secondary"
             href="?p={{ page.next_page_number }}&bucket={{ bucket }}&state={{ state }}&q={{ q|urlencode }}">
            Suiv.
          </a>
        {% endif %}
      </div>
    {% endif %}
  </div>
{% else %}
  <div class="card shadow-sm">
    <div class="card-body text-secondary">Aucune récompense trouvée pour ces critères.</div>
  </div>
{% endif %}
{% endblock %}
===== ./templates/rewards/confirm_delete.html =====
{# templates/rewards/confirm_delete.html #}
{% extends "base_dashboard.html" %}
{% block title %}Supprimer la récompense{% endblock %}

{% block content %}
<header class="mb-3">
  <h1 class="h4 section-title mb-1">Supprimer la récompense</h1>
</header>

<div class="card shadow-sm">
  <div class="card-body">
    <p>Supprimer définitivement <strong>{{ reward.label }}</strong> ?</p>
    <form method="post" class="d-flex gap-2">
      {% csrf_token %}
      <button class="btn btn-danger" type="submit">Supprimer</button>
      <a class="btn btn-outline-secondary" href="{% url 'rewards:list' %}">Annuler</a>
    </form>
  </div>
</div>
{% endblock %}
===== ./templates/rewards/use_reward_done.html =====
{% extends "base_dashboard.html" %}
{% block title %}Récompense utilisée{% endblock %}

{% block content %}
<div class="card shadow-sm">
  <div class="card-body text-center">
    <h2 class="h4 mb-3">🎉 Bravo !</h2>
    <p>Vous venez d’utiliser la récompense :</p>
    <h3 class="h5">{{ reward.label }}</h3>
    <p class="text-secondary">Statut : <span class="badge bg-success">Utilisée</span></p>
  </div>
</div>
{% endblock %}

